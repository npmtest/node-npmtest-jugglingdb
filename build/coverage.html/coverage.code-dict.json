{"/home/travis/build/npmtest/node-npmtest-jugglingdb/test.js":"/* istanbul instrument in package npmtest_jugglingdb */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jugglingdb/lib.npmtest_jugglingdb.js":"/* istanbul instrument in package npmtest_jugglingdb */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_jugglingdb = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_jugglingdb = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-jugglingdb/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-jugglingdb && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_jugglingdb */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_jugglingdb\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_jugglingdb.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_jugglingdb.rollup.js'] =\n            local.assetsDict['/assets.npmtest_jugglingdb.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_jugglingdb.__dirname + '/lib.npmtest_jugglingdb.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jugglingdb/node_modules/jugglingdb/index.js":"var fs = require('fs');\nvar path = require('path');\n\nvar Schema = exports.Schema = require('./lib/schema').Schema;\nexports.AbstractClass = require('./lib/model.js');\n\nvar baseSQL = './lib/sql';\n\nexports.__defineGetter__('BaseSQL', function () {\n    return require(baseSQL);\n});\n\nexports.loadSchema = function(filename, settings, compound) {\n    var schema = [];\n    var definitions = require(filename);\n    Object.keys(definitions).forEach(function(k) {\n        var conf = settings[k];\n        if (!conf) {\n            console.log('No config found for ' + k + ' schema, using in-memory schema');\n            conf = {driver: 'memory'};\n        }\n        schema[k] = new Schema(conf.driver, conf);\n        schema[k].on('define', function(m, name, prop, sett) {\n            compound.models[name] = m;\n            if (conf.backyard) {\n                schema[k].backyard.define(name, prop, sett);\n            }\n        });\n        schema[k].name = k;\n        schema.push(schema[k]);\n        if (conf.backyard) {\n            schema[k].backyard = new Schema(conf.backyard.driver, conf.backyard);\n        }\n        if ('function' === typeof definitions[k]) {\n            define(schema[k], definitions[k]);\n            if (conf.backyard) {\n                define(schema[k].backyard, definitions[k]);\n            }\n        }\n    });\n\n    return schema;\n\n    function define(db, def) {\n        def(db, compound);\n    }\n};\n\nexports.init = function (compound) {\n    if (global.railway) {\n        global.railway.orm = exports;\n    } else {\n        compound.orm = {\n            Schema: exports.Schema,\n            AbstractClass: exports.AbstractClass\n        };\n        if (compound.app.enabled('noeval schema')) {\n            compound.orm.schema = exports.loadSchema(\n                compound.root + '/db/schema',\n                compound.app.get('database'),\n                compound\n            );\n            if (compound.app.enabled('autoupdate')) {\n                compound.on('ready', function() {\n                    compound.orm.schema.forEach(function(s) {\n                        s.autoupdate();\n                        if (s.backyard) {\n                            s.backyard.autoupdate();\n                            s.backyard.log = s.log;\n                        }\n                    });\n                });\n            }\n            return;\n        }\n    }\n\n    // legacy stuff\n\n    if (compound.version > '1.1.5-15') {\n        compound.on('after routes', initialize);\n    } else {\n        initialize();\n    }\n\n    function initialize() {\n        var railway = './lib/railway', init;\n        try {\n            init = require(railway);\n        } catch (e) {\n            console.log(e.stack);\n        }\n        if (init) {\n            init(compound);\n        }\n    }\n};\n\nexports.__defineGetter__('version', function () {\n    return JSON.parse(fs.readFileSync(__dirname + '/package.json')).version;\n});\n\nvar commonTest = './test/common_test';\nexports.__defineGetter__('test', function () {\n    return require(commonTest);\n});\n","/home/travis/build/npmtest/node-npmtest-jugglingdb/node_modules/jugglingdb/lib/schema.js":"/**\n * Module dependencies\n */\nvar AbstractClass = require('./model.js');\nvar List = require('./list.js');\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar path = require('path');\nvar fs = require('fs');\nvar when = require('when');\n\nvar existsSync = fs.existsSync || path.existsSync;\n\n/**\n * Export public API\n */\nexports.Schema = Schema;\n// exports.AbstractClass = AbstractClass;\n\n/**\n * Helpers\n */\nvar slice = Array.prototype.slice;\n\nSchema.Text = function Text(s) { return s; };\nSchema.JSON = function JSON() {};\n\nSchema.types = {};\nSchema.registerType = function (type) {\n    this.types[type.name] = type;\n};\n\nSchema.registerType(Schema.Text);\nSchema.registerType(Schema.JSON);\n\n\n/**\n * Schema - adapter-specific classes factory.\n *\n * All classes in single schema shares same adapter type and\n * one database connection\n *\n * @param name - type of schema adapter (mysql, mongoose, sequelize, redis)\n * @param settings - any database-specific settings which we need to\n * establish connection (of course it depends on specific adapter)\n *\n * - host\n * - port\n * - username\n * - password\n * - database\n * - debug {Boolean} = false\n *\n * @example Schema creation, waiting for connection callback\n * ```\n * var schema = new Schema('mysql', { database: 'myapp_test' });\n * schema.define(...);\n * schema.on('connected', function () {\n *     // work with database\n * });\n * ```\n */\nfunction Schema(name, settings) {\n    var schema = this;\n    // just save everything we get\n    this.name = name;\n    this.settings = settings || {};\n\n    // Disconnected by default\n    this.connected = false;\n    this.connecting = false;\n\n    // create blank models pool\n    this.models = {};\n    this.definitions = {};\n\n    if (this.settings.log) {\n        this.on('log', function(str, duration) {\n            console.log(str);\n        });\n    }\n\n    // and initialize schema using adapter\n    // this is only one initialization entry point of adapter\n    // this module should define `adapter` member of `this` (schema)\n    var adapter;\n    if (typeof name === 'object') {\n        adapter = name;\n        this.name = adapter.name;\n    } else if (name.match(/^\\//)) {\n        // try absolute path\n        adapter = require(name);\n    } else if (existsSync(__dirname + '/adapters/' + name + '.js')) {\n        // try built-in adapter\n        adapter = require('./adapters/' + name);\n    } else {\n        // try foreign adapter\n        try {\n            adapter = require('jugglingdb-' + name);\n        } catch (e) {\n            return console.log('\\nWARNING: JugglingDB adapter \"' + name + '\" is not installed,\\nso your models would not work, to fix run:\\n\\n    npm install jugglingdb-' + name, '\\n');\n        }\n    }\n\n    this.connecting = true;\n    adapter.initialize(this, function () {\n\n        this.adapter.log = function (query, start) {\n            schema.log(query, start);\n        };\n\n        this.adapter.logger = function (query) {\n            var t1 = Date.now();\n            var log = this.log;\n            return function (q) {\n                log(q || query, t1);\n            };\n        };\n\n        this.connecting = false;\n        this.connected = true;\n        this.emit('connected');\n\n    }.bind(this));\n\n    // we have an adaper now?\n    if (!this.adapter) {\n        this.emit('disconnected');\n        throw new Error('Adapter \"' + name + '\" is not defined correctly: it should define `adapter` member of schema synchronously');\n    }\n\n    schema.connect = function(cb) {\n        var schema = this;\n        schema.connecting = true;\n        return new when.Promise(function(resolve, reject) {\n            if (!schema.adapter.connect) {\n                return process.nextTick(function() {\n                    schema.connecting = false;\n                    if (cb) {\n                        cb(null, schema);\n                    }\n                    return resolve(schema);\n                });\n            }\n            schema.adapter.connect(function(err) {\n                if (err) {\n                    schema.connected = false;\n                    schema.connecting = false;\n                    reject(err);\n                    if (cb) {\n                        cb(err);\n                    }\n                } else {\n                    schema.connected = true;\n                    schema.connecting = false;\n                    schema.emit('connected');\n                    resolve(schema);\n                    if (cb) {\n                        cb(null, schema);\n                    }\n                }\n            });\n        });\n    };\n}\n\nutil.inherits(Schema, EventEmitter);\n\n/**\n * Define class\n *\n * @param {String} className\n * @param {Object} properties - hash of class properties in format\n *   `{property: Type, property2: Type2, ...}`\n *   or\n *   `{property: {type: Type}, property2: {type: Type2}, ...}`\n * @param {Object} settings - other configuration of class\n * @return newly created class\n *\n * @example simple case\n * ```\n * var User = schema.define('User', {\n *     email: String,\n *     password: String,\n *     birthDate: Date,\n *     activated: Boolean\n * });\n * ```\n * @example more advanced case\n * ```\n * var User = schema.define('User', {\n *     email: { type: String, limit: 150, index: true },\n *     password: { type: String, limit: 50 },\n *     birthDate: Date,\n *     registrationDate: {type: Date, default: function () { return new Date }},\n *     activated: { type: Boolean, default: false }\n * });\n * ```\n */\nSchema.prototype.define = function defineClass(className, properties, settings) {\n    var schema = this;\n    var args = slice.call(arguments);\n\n    if (!className) {\n        throw new Error('Class name required');\n    }\n    if (args.length == 1) {\n        properties = {};\n        args.push(properties);\n    }\n    if (args.length == 2) {\n        settings = {};\n        args.push(settings);\n    }\n\n    settings = settings || {};\n\n    if ('function' === typeof properties) {\n        var props = {};\n        properties({\n            property: function(name, type, settings) {\n                settings = settings || {};\n                settings.type = type;\n                props[name] = settings;\n            },\n            set: function(key, val) {\n                settings[key] = val;\n            }\n        });\n        properties = props;\n    }\n\n    properties = properties || {};\n\n    // every class can receive hash of data as optional param\n    var NewClass = function ModelConstructor(data, schema) {\n        if (!(this instanceof ModelConstructor)) {\n            return new ModelConstructor(data);\n        }\n        AbstractClass.call(this, data);\n        hiddenProperty(this, 'schema', schema || this.constructor.schema);\n    };\n\n    hiddenProperty(NewClass, 'schema', schema);\n    hiddenProperty(NewClass, 'settings', settings);\n    hiddenProperty(NewClass, 'properties', properties);\n    hiddenProperty(NewClass, 'modelName', className);\n    hiddenProperty(NewClass, 'tableName', settings.table || className);\n    hiddenProperty(NewClass, 'relations', {});\n\n    // inherit AbstractClass methods\n    for (var i in AbstractClass) {\n        NewClass[i] = AbstractClass[i];\n    }\n    for (var j in AbstractClass.prototype) {\n        NewClass.prototype[j] = AbstractClass.prototype[j];\n    }\n\n    NewClass.getter = {};\n    NewClass.setter = {};\n\n    standartize(properties, settings);\n\n    // store class in model pool\n    this.models[className] = NewClass;\n    this.definitions[className] = {\n        properties: properties,\n        settings: settings\n    };\n\n    // pass control to adapter\n    this.adapter.define({\n        model:      NewClass,\n        properties: properties,\n        settings:   settings\n    });\n\n    NewClass.prototype.__defineGetter__('id', function () {\n        return this.__data.id;\n    });\n\n    properties.id = properties.id || { type: schema.settings.slave ? String : Number };\n\n    NewClass.forEachProperty = function (cb) {\n        Object.keys(properties).forEach(cb);\n    };\n\n    NewClass.registerProperty = function (attr) {\n        var DataType = properties[attr].type;\n        if (DataType instanceof Array) {\n            DataType = List;\n        } else if (DataType.name === 'Date') {\n            var OrigDate = Date;\n            DataType = function Date(arg) {\n                return new OrigDate(arg);\n            };\n        } else if (DataType.name === 'JSON' || DataType === JSON) {\n            DataType = function JSON(s) {\n                return s;\n            };\n        } else if (DataType.name === 'Text' || DataType === Schema.Text) {\n            DataType = function Text(s) {\n                return s;\n            };\n        }\n\n        Object.defineProperty(NewClass.prototype, attr, {\n            get: function () {\n                if (NewClass.getter[attr]) {\n                    return NewClass.getter[attr].call(this);\n                } else {\n                    return this.__data[attr];\n                }\n            },\n            set: function (value) {\n                if (NewClass.setter[attr]) {\n                    NewClass.setter[attr].call(this, value);\n                } else {\n                    if (value === null || value === undefined || typeof DataType === 'object') {\n                        this.__data[attr] = value;\n                    } else if (DataType === Boolean) {\n                        this.__data[attr] = value === 'false' ? false : !!value;\n                    } else {\n                        this.__data[attr] = DataType(value);\n                    }\n                }\n            },\n            configurable: true,\n            enumerable: true\n        });\n\n        NewClass.prototype.__defineGetter__(attr + '_was', function () {\n            return this.__dataWas[attr];\n        });\n\n        Object.defineProperty(NewClass.prototype, '_' + attr, {\n            get: function () {\n                return this.__data[attr];\n            },\n            set: function (value) {\n                this.__data[attr] = value;\n            },\n            configurable: true,\n            enumerable: false\n        });\n    };\n\n    NewClass.forEachProperty(NewClass.registerProperty);\n\n    this.emit('define', NewClass, className, properties, settings);\n\n    return NewClass;\n\n};\n\n    function standartize(properties, settings) {\n        Object.keys(properties).forEach(function (key) {\n            var v = properties[key];\n            if (\n                typeof v === 'function' ||\n                typeof v === 'object' && v && v.constructor.name === 'Array'\n            ) {\n                properties[key] = { type: v };\n            }\n        });\n        // TODO: add timestamps fields\n        // when present in settings: {timestamps: true}\n        // or {timestamps: {created: 'created_at', updated: false}}\n        // by default property names: createdAt, updatedAt\n    }\n\n/**\n * Define single property named `prop` on `model`\n *\n * @param {String} model - name of model\n * @param {String} prop - name of propery\n * @param {Object} params - property settings\n */\nSchema.prototype.defineProperty = function (model, prop, params) {\n    this.definitions[model].properties[prop] = params;\n    this.models[model].registerProperty(prop);\n    if (this.adapter.defineProperty) {\n        this.adapter.defineProperty(model, prop, params);\n    }\n};\n\n/**\n * Extend existing model with bunch of properties\n *\n * @param {String} model - name of model\n * @param {Object} props - hash of properties\n *\n * Example:\n *\n *     // Instead of doing this:\n *\n *     // amend the content model with competition attributes\n *     db.defineProperty('Content', 'competitionType', { type: String });\n *     db.defineProperty('Content', 'expiryDate', { type: Date, index: true });\n *     db.defineProperty('Content', 'isExpired', { type: Boolean, index: true });\n *\n *     // schema.extend allows to\n *     // extend the content model with competition attributes\n *     db.extendModel('Content', {\n *       competitionType: String,\n *       expiryDate: { type: Date, index: true },\n *       isExpired: { type: Boolean, index: true }\n *     });\n */\nSchema.prototype.extendModel = function (model, props) {\n    var t = this;\n    standartize(props, {});\n    Object.keys(props).forEach(function (propName) {\n        var definition = props[propName];\n        t.defineProperty(model, propName, definition);\n    });\n};\n\n/**\n * Drop each model table and re-create.\n * This method make sense only for sql adapters.\n *\n * @warning All data will be lost! Use autoupdate if you need your data.\n */\nSchema.prototype.automigrate = function (cb) {\n    this.freeze();\n    if (this.adapter.automigrate) {\n        this.adapter.automigrate(cb);\n    } else if (cb) {\n        cb();\n    }\n};\n\n/**\n * Update existing database tables.\n * This method make sense only for sql adapters.\n */\nSchema.prototype.autoupdate = function (cb) {\n    this.freeze();\n    if (this.adapter.autoupdate) {\n        this.adapter.autoupdate(cb);\n    } else if (cb) {\n        cb();\n    }\n};\n\n/**\n * Check whether migrations needed\n * This method make sense only for sql adapters.\n */\nSchema.prototype.isActual = function (cb) {\n    this.freeze();\n    if (this.adapter.isActual) {\n        this.adapter.isActual(cb);\n    } else if (cb) {\n        cb(null, true);\n    }\n};\n\n/**\n * Log benchmarked message. Do not redefine this method, if you need to grab\n * chema logs, use `schema.on('log', ...)` emitter event\n *\n * @private used by adapters\n */\nSchema.prototype.log = function (sql, t) {\n    this.emit('log', sql, t);\n};\n\n/**\n * Freeze schema. Behavior depends on adapter\n */\nSchema.prototype.freeze = function freeze() {\n    if (this.adapter.freezeSchema) {\n        this.adapter.freezeSchema();\n    }\n};\n\n/**\n * Backward compatibility. Use model.tableName prop instead.\n * Return table name for specified `modelName`\n * @param {String} modelName\n */\nSchema.prototype.tableName = function (modelName) {\n    return this.models[modelName].model.tableName;\n};\n\n/**\n * Define foreign key\n * @param {String} className\n * @param {String} key - name of key field\n */\nSchema.prototype.defineForeignKey = function defineForeignKey(className, key, foreignClassName) {\n    // quit if key already defined\n    if (this.definitions[className].properties[key]) return;\n\n    if (this.adapter.defineForeignKey) {\n        var cb = function (err, keyType) {\n            if (err) throw err;\n            this.definitions[className].properties[key] = {type: keyType};\n        }.bind(this);\n        switch (this.adapter.defineForeignKey.length) {\n            case 4:\n                this.adapter.defineForeignKey(className, key, foreignClassName, cb);\n            break;\n            default:\n            case 3:\n                this.adapter.defineForeignKey(className, key, cb);\n            break;\n        }\n    } else {\n        this.definitions[className].properties[key] = {type: Number};\n    }\n    this.models[className].registerProperty(key);\n};\n\n/**\n * Close database connection\n */\nSchema.prototype.disconnect = function disconnect(cb) {\n    if (typeof this.adapter.disconnect === 'function') {\n        this.connected = false;\n        this.adapter.disconnect(cb);\n        this.emit('disconnected');\n    } else if (cb) {\n        cb();\n    }\n};\n\nSchema.prototype.copyModel = function copyModel(Master) {\n    var schema = this;\n    var className = Master.modelName;\n    var md = Master.schema.definitions[className];\n    var Slave = function SlaveModel() {\n        Master.apply(this, [].slice.call(arguments));\n        this.schema = schema;\n    };\n\n    util.inherits(Slave, Master);\n\n    Slave.__proto__ = Master;\n\n    hiddenProperty(Slave, 'schema', schema);\n    hiddenProperty(Slave, 'modelName', className);\n    hiddenProperty(Slave, 'tableName', Master.tableName);\n    hiddenProperty(Slave, 'relations', Master.relations);\n\n    if (!(className in schema.models)) {\n\n        // store class in model pool\n        schema.models[className] = Slave;\n        schema.definitions[className] = {\n            properties: md.properties,\n            settings: md.settings\n        };\n\n        if (!schema.isTransaction) {\n            schema.adapter.define({\n                model:      Slave,\n                properties: md.properties,\n                settings:   md.settings\n            });\n        }\n\n    }\n\n    return Slave;\n};\n\nSchema.prototype.transaction = function() {\n    var schema = this;\n    var transaction = new EventEmitter();\n    transaction.isTransaction = true;\n    transaction.origin = schema;\n    transaction.name = schema.name;\n    transaction.settings = schema.settings;\n    transaction.connected = false;\n    transaction.connecting = false;\n    transaction.adapter = schema.adapter.transaction();\n\n    // create blank models pool\n    transaction.models = {};\n    transaction.definitions = {};\n\n    for (var i in schema.models) {\n        schema.copyModel.call(transaction, schema.models[i]);\n    }\n\n    transaction.connect = schema.connect;\n\n    transaction.exec = function(cb) {\n        transaction.adapter.exec(cb);\n    };\n\n    return transaction;\n};\n\n/**\n * Define hidden property\n */\nfunction hiddenProperty(where, property, value) {\n    Object.defineProperty(where, property, {\n        writable: false,\n        enumerable: false,\n        configurable: false,\n        value: value\n    });\n}\n\n/**\n * Define readonly property on object\n *\n * @param {Object} obj\n * @param {String} key\n * @param {Mixed} value\n */\nfunction defineReadonlyProp(obj, key, value) {\n    Object.defineProperty(obj, key, {\n        writable: false,\n        enumerable: true,\n        configurable: true,\n        value: value\n    });\n}\n\n","/home/travis/build/npmtest/node-npmtest-jugglingdb/node_modules/jugglingdb/lib/model.js":"/**\n * Module exports class Model\n */\nmodule.exports = AbstractClass;\n\n/**\n * Module dependencies\n */\nvar setImmediate = global.setImmediate || process.nextTick;\nvar util = require('util');\nvar validations = require('./validations.js');\nvar ValidationError = validations.ValidationError;\nvar List = require('./list.js');\nvar when = require('when');\nrequire('./hooks.js');\nrequire('./relations.js');\nrequire('./include.js');\n\nvar BASE_TYPES = ['String', 'Boolean', 'Number', 'Date', 'Text'];\n\n/**\n * Model class - base class for all persist objects\n * provides **common API** to access any database adapter.\n * This class describes only abstract behavior layer, refer to `lib/adapters/*.js`\n * to learn more about specific adapter implementations\n *\n * `AbstractClass` mixes `Validatable` and `Hookable` classes methods\n *\n * @constructor\n * @param {Object} data - initial object data\n */\nfunction AbstractClass(data) {\n    this._initProperties(data, true);\n}\n\nvar promisedClassMethods = [\n    'create', 'all', 'destroyAll', 'upsert', 'updateOrCreate', 'find', 'update',\n    'findOne', 'exists', 'count'\n];\n\nvar promisedInstanceMethods = [\n    'save', 'updateAttribute', 'updateAttributes', 'destroy', 'reload'\n];\n\nAbstractClass.prototype._initProperties = function (data, applySetters) {\n    var self = this;\n    var ctor = this.constructor;\n    var ds = ctor.schema.definitions[ctor.modelName];\n    var properties = ds.properties;\n    data = data || {};\n\n    Object.defineProperty(this, '__cachedRelations', {\n        writable: true,\n        enumerable: false,\n        configurable: true,\n        value: {}\n    });\n\n    Object.defineProperty(this, '__data', {\n        writable: true,\n        enumerable: false,\n        configurable: true,\n        value: {}\n    });\n\n    Object.defineProperty(this, '__dataWas', {\n        writable: true,\n        enumerable: false,\n        configurable: true,\n        value: {}\n    });\n\n    if (data.__cachedRelations) {\n        this.__cachedRelations = data.__cachedRelations;\n    }\n\n    for (var i in data) {\n        if (i in properties) {\n            this.__data[i] = this.__dataWas[i] = data[i];\n        } else if (i in ctor.relations) {\n            this.__data[ctor.relations[i].keyFrom] = this.__dataWas[i] = data[i][ctor.relations[i].keyTo];\n            this.__cachedRelations[i] = data[i];\n        }\n    }\n\n    if (applySetters === true) {\n        Object.keys(data).forEach(function (attr) {\n            self[attr] = data[attr];\n        });\n    }\n\n    ctor.forEachProperty(function (attr) {\n\n        if ('undefined' === typeof self.__data[attr]) {\n            self.__data[attr] = self.__dataWas[attr] = getDefault(attr);\n        } else {\n            self.__dataWas[attr] = self.__data[attr];\n        }\n\n    });\n\n    ctor.forEachProperty(function (attr) {\n\n        var type = properties[attr].type;\n\n        if (BASE_TYPES.indexOf(type.name) === -1) {\n            if (typeof self.__data[attr] !== 'object' && self.__data[attr]) {\n                try {\n                    self.__data[attr] = JSON.parse(self.__data[attr] + '');\n                } catch (e) {\n                    self.__data[attr] = String(self.__data[attr]);\n                }\n            }\n            if (type.name === 'Array' || typeof type === 'object' && type.constructor.name === 'Array') {\n                self.__data[attr] = new List(self.__data[attr], type, self);\n            }\n        }\n\n    });\n\n    function getDefault(attr) {\n        var def = properties[attr]['default'];\n        if (isdef(def)) {\n            if (typeof def === 'function') {\n                return def();\n            } else {\n                return def;\n            }\n        } else {\n            return undefined;\n        }\n    }\n\n    this.trigger('initialize');\n};\n\n/**\n * @param {String} prop - property name\n * @param {Object} params - various property configuration\n */\nAbstractClass.defineProperty = function (prop, params) {\n    this.schema.defineProperty(this.modelName, prop, params);\n};\n\nAbstractClass.whatTypeName = function (propName) {\n    var prop = this.schema.definitions[this.modelName].properties[propName];\n    if (!prop || !prop.type) {\n        return null;\n        // throw new Error('Undefined type for ' + this.modelName + ':' + propName);\n    }\n    return prop.type.name;\n};\n\n/**\n * Updates the respective record\n *\n * @param {Object} params - { where:{uid:'10'}, update:{ Name:'New name' } }\n * @param callback(err, obj)\n */\nAbstractClass.update = function (params, cb) {\n    var Model = this;\n    if (params && params.update) {\n      params.update = this._forDB(params.update);\n    }\n    this.schema.adapter.update(this.modelName, params, function(err, obj) {\n      cb(err, Model._fromDB(obj));\n    });\n};\n\n/**\n * Prepares data for storage adapter.\n *\n * Ensures data is allowed by the schema, and stringifies JSON field types.\n * If the schema defines a custom field name, it is transformed here.\n *\n * @param {Object} data\n * @return {Object} Returns data for storage.\n */\nAbstractClass._forDB = function (data) {\n    if (!data) return;\n    var res = {};\n    var definition = this.schema.definitions[this.modelName].properties;\n    Object.keys(data).forEach(function (propName) {\n        var val;\n        var typeName = this.whatTypeName(propName);\n        if (!typeName && !data[propName] instanceof Array) {\n            return;\n        }\n        val = data[propName];\n        if (definition[propName] && definition[propName].name) {\n          // Use different name for DB field/column\n          res[definition[propName].name] = val;\n        } else {\n          res[propName] = val;\n        }\n    }.bind(this));\n    return res;\n};\n\n/**\n * Unpacks data from storage adapter.\n *\n * If the schema defines a custom field name, it is transformed here.\n *\n * @param {Object} data\n * @return {Object}\n */\nAbstractClass._fromDB = function (data) {\n    if (!data) return;\n    var definition = this.schema.definitions[this.modelName].properties;\n    var propNames = Object.keys(data);\n    Object.keys(definition).forEach(function (defPropName) {\n      var customName = definition[defPropName].name;\n      if (customName && propNames.indexOf(customName) !== -1) {\n        data[defPropName] = data[customName];\n        delete data[customName];\n      }\n    });\n    return data;\n};\n\nAbstractClass.prototype.whatTypeName = function (propName) {\n    return this.constructor.whatTypeName(propName);\n};\n\n/**\n * Create new instance of Model class, saved in database\n *\n * @param data [optional]\n * @param callback(err, obj)\n * callback called with arguments:\n *\n *   - err (null or Error)\n *   - instance (null or Model)\n */\nAbstractClass.create = function (data, callback) {\n\n    var Model = this;\n    var modelName = Model.modelName;\n\n    if (typeof data === 'function') {\n        callback = data;\n        data = {};\n    }\n\n    if (typeof callback !== 'function') {\n        callback = function () {};\n    }\n\n    if (!data) {\n        data = {};\n    }\n\n    // Passed via data from save\n    var options = data.options || { validate: true };\n\n    if (data.data instanceof Model) {\n        data = data.data;\n        data.__dataWas = data.__data;\n    }\n\n    if (data instanceof Array) {\n        var instances = Array(data.length);\n        var errors = Array(data.length);\n        var gotError = false;\n        var wait = data.length;\n        if (wait === 0) callback(null, []);\n\n        for (var i = 0; i < data.length; i += 1) {\n            createModel(data[i], i);\n        }\n\n        return instances;\n    }\n\n    function createModel(d, i) {\n        Model.create(d, function(err, inst) {\n            if (err) {\n                errors[i] = err;\n                gotError = true;\n            }\n            instances[i] = inst;\n            modelCreated();\n        });\n    }\n\n    function modelCreated() {\n        if (--wait === 0) {\n            callback(gotError ? errors : null, instances);\n        }\n    }\n\n    var obj;\n    // if we come from save\n    if (data instanceof Model && !data.id) {\n        obj = data;\n    } else {\n        obj = new Model(data);\n    }\n    data = obj.toObject(true);\n\n    if (!options.validate) {\n        create();\n    }\n    else {\n        // validation required\n        obj.isValid(function(err, valid) {\n            if (valid) {\n                create();\n            } else {\n                err = err || new ValidationError(obj);\n                callback(err, obj);\n            }\n        }, data);\n    }\n\n    function create() {\n        obj.trigger('create', function(createDone) {\n            obj.trigger('save', function(saveDone) {\n\n                this._adapter().create(modelName, this.constructor._forDB(obj.toObject(true)), function (err, id, rev) {\n                    if (id) {\n                        obj.__data.id = id;\n                        obj.__dataWas.id = id;\n                        defineReadonlyProp(obj, 'id', id);\n                    }\n                    if (rev) {\n                        rev = Model._fromDB(rev);\n                        obj._rev = rev;\n                    }\n                    // if error occurs, we should not return a valid obj\n                    if (err) {\n                        return callback(err, obj);\n                    }\n                    saveDone.call(obj, function () {\n                        createDone.call(obj, function () {\n                            callback(err, obj);\n                        });\n                    });\n                }, obj);\n            }, obj, callback);\n        }, obj, callback);\n    }\n\n    return obj;\n};\n\nfunction connection(schema) {\n    if (schema.connected) {\n        return when.Promise.resolve();\n    } else {\n        if (schema.connecting) {\n            return new when.Promise(function(resolve) {\n                schema.once('connected', function () {\n                    resolve();\n                });\n            });\n        } else {\n            return schema.connect();\n        }\n    }\n}\n\n/**\n * Update or insert\n */\nAbstractClass.upsert = AbstractClass.updateOrCreate = function upsert(data, callback) {\n\n    var Model = this;\n    if (!data.id) return this.create(data, callback);\n    if (this.schema.adapter.updateOrCreate) {\n        var inst = new Model(data);\n        this.schema.adapter.updateOrCreate(Model.modelName, Model._forDB(inst.toObject(true)), function (err, data) {\n            var obj;\n            if (data) {\n                data = inst.constructor._fromDB(data);\n                inst._initProperties(data);\n                obj = inst;\n            } else {\n                obj = null;\n            }\n            callback(err, obj);\n        });\n    } else {\n        this.find(data.id, function (err, inst) {\n            if (err) return callback(err);\n            if (inst) {\n                inst.updateAttributes(data, callback);\n            } else {\n                var obj = new Model(data);\n                obj.save(data, callback);\n            }\n        });\n    }\n};\n\n/**\n * Find one record, same as `all`, limited by 1 and return object, not collection,\n * if not found, create using data provided as second argument\n *\n * @param {Object} query - search conditions: {where: {test: 'me'}}.\n * @param {Object} data - object to create.\n * @param {Function} cb - callback called with (err, instance)\n */\nAbstractClass.findOrCreate = function findOrCreate(query, data, callback) {\n    if (typeof query === 'undefined') {\n        query = {where: {}};\n    }\n    if (typeof data === 'function' || typeof data === 'undefined') {\n        callback = data;\n        data = query && query.where;\n    }\n    if (typeof callback === 'undefined') {\n        callback = function () {};\n    }\n\n    var t = this;\n    this.findOne(query, function (err, record) {\n        if (err) return callback(err);\n        if (record) return callback(null, record);\n        t.create(data, callback);\n    });\n};\n\n/**\n * Check whether object exitst in database\n *\n * @param {id} id - identifier of object (primary key value)\n * @param {Function} cb - callbacl called with (err, exists: Bool)\n */\nAbstractClass.exists = function exists(id, cb) {\n    if (id) {\n        this.schema.adapter.exists(this.modelName, id, cb);\n    } else {\n        cb(new Error('Model::exists requires positive id argument'));\n    }\n};\n\n/**\n * Find object by id\n *\n * @param {id} id - primary key value\n * @param {Function} cb - callback called with (err, instance)\n */\nAbstractClass.find = function find(id, cb) {\n    var Model = this;\n\n    this.schema.adapter.find(Model.modelName, id, function (err, data) {\n        var obj = null;\n        if (data) {\n            data = Model._fromDB(data);\n            if (!data.id) {\n                data.id = id;\n            }\n            obj = new Model();\n            obj._initProperties(data, false);\n        }\n        cb(err, obj);\n    });\n};\n\n/**\n * Find all instances of Model, matched by query\n * make sure you have marked as `index: true` fields for filter or sort\n *\n * @param {Object} params (optional)\n *\n * - where: Object `{ key: val, key2: {gt: 'val2'}}`\n * - attributes: Array ['id, 'name'] or String 'id'\n * - include: String, Object or Array. See AbstractClass.include documentation.\n * - order: String\n * - limit: Number\n * - skip: Number\n *\n * @param {Function} callback (required) called with arguments:\n *\n * - err (null or Error)\n * - Array of instances\n */\nAbstractClass.all = function all(params, cb) {\n\n    if (arguments.length === 1) {\n        cb = params;\n        params = null;\n    }\n    if (params) {\n        if ('skip' in params) {\n            params.offset = params.skip;\n        } else if ('offset' in params) {\n            params.skip = params.offset;\n        }\n    }\n    var Constr = this;\n    var paramsFiltered = params;\n    if (params && params.where) {\n      paramsFiltered.where = this._forDB(paramsFiltered.where);\n    }\n    this.schema.adapter.all(this.modelName, paramsFiltered, function (err, data) {\n        if (data && data.forEach) {\n            if (params && params.attributes && data && data.length) {\n                if ('string' === typeof params.attributes) {\n                    return cb(err, data.map(function(n) {\n                        return n[params.attributes];\n                    }));\n                } else if ('function' === typeof data.map) {\n                    var isClean = Object.getOwnPropertyNames(data[0]).every(function(key) {\n                        return params.attributes.indexOf(key) !== -1;\n                    });\n                    if (!isClean) {\n                        data.forEach(function(node) {\n                            Object.keys(node).forEach(function(key) {\n                                if (params.attributes.indexOf(key) === -1) {\n                                    delete node[key];\n                                }\n                            });\n                        });\n                    }\n                }\n            }\n            if (!params || !params.onlyKeys) {\n                data.forEach(function (d, i) {\n                    var obj = new Constr();\n                    d = Constr._fromDB(d);\n                    obj._initProperties(d, false);\n                    if (params && params.include && params.collect) {\n                        data[i] = obj.__cachedRelations[params.collect];\n                    } else {\n                        data[i] = obj;\n                    }\n                });\n            }\n            if (data && data.countBeforeLimit) {\n                data.countBeforeLimit = data.countBeforeLimit;\n            }\n            cb(err, data);\n        } else {\n            cb(err, []);\n        }\n    });\n};\n\n/**\n * Iterate through dataset and perform async method iterator. This method\n * designed to work with large datasets loading data by batches.\n *\n * @param {Object} filter - query conditions. Same as for `all` may contain\n * optional member `batchSize` to specify size of batch loaded from db. Optional.\n * @param {Function} iterator - method(obj, next) called on each obj.\n * @param {Function} callback - method(err) called on complete or error.\n */\nAbstractClass.iterate = function map(filter, iterator, callback) {\n    var Model = this;\n    if ('function' === typeof filter) {\n        if ('function' === typeof iterator) {\n            callback = iterator;\n        }\n        iterator = filter;\n        filter = {};\n    }\n\n    var concurrent = filter.concurrent;\n    delete filter.concurrent;\n    var limit = filter.limit;\n    var batchSize = filter.limit = filter.batchSize || 1000;\n    var batchNumber = filter.batchNumber || -1;\n\n    nextBatch();\n\n    function nextBatch() {\n        // console.log(batchNumber);\n        batchNumber += 1;\n        filter.skip = filter.offset = batchNumber * batchSize;\n        if (limit < batchSize) {\n            if (limit <= 0) {\n                return done();\n            } else {\n                filter.limit = limit;\n            }\n        }\n        limit -= batchSize;\n        Model.all(filter).then(function(collection) {\n            if (collection.length === 0) {\n                return done();\n            }\n            var i = 0, wait;\n            if (concurrent) {\n                wait = collection.length;\n                collection.forEach(function(obj, i) {\n                    iterator(obj, next, filter.offset + i);\n                    obj = null;\n                });\n                collection = null;\n            } else {\n                nextItem();\n            }\n            function next() {\n                if (--wait === 0) {\n                    nextBatch();\n                }\n            }\n            function nextItem(err) {\n                if (err) {\n                    return done(err);\n                }\n                var item = collection[i];\n                if (i > collection.length - 1) {\n                    return nextBatch();\n                }\n                i += 1;\n                setImmediate(function() {\n                    iterator(item, nextItem, filter.offset + i);\n                });\n            }\n        }).catch(done);\n    }\n\n    function done(err) {\n        if ('function' === typeof callback) {\n            callback(err);\n        }\n    }\n};\n\n/**\n * Find one record, same as `all`, limited by 1 and return object, not collection\n *\n * @param {Object} params - search conditions: {where: {test: 'me'}}\n * @param {Function} cb - callback called with (err, instance)\n */\nAbstractClass.findOne = function findOne(params, cb) {\n\n    if (typeof params === 'function') {\n        cb = params;\n        params = {};\n    }\n    params.limit = 1;\n    this.all(params, function (err, collection) {\n        if (err || !collection || collection.length < 1) {\n            return cb(err, null);\n        }\n        cb(err, collection[0]);\n    });\n};\n\n/**\n * Destroy all records\n * @param {Function} cb - callback called with (err)\n */\nAbstractClass.destroyAll = function destroyAll(cb) {\n    this.schema.adapter.destroyAll(this.modelName, function (err) {\n        if ('function' === typeof cb) {\n            cb(err);\n        }\n    });\n};\n\n/**\n * Return count of matched records\n *\n * @param {Object} where - search conditions (optional)\n * @param {Function} cb - callback, called with (err, count)\n */\nAbstractClass.count = function (where, cb) {\n    if (typeof where === 'function') {\n        cb = where;\n        where = null;\n    }\n    this.schema.adapter.count(this.modelName, cb, this._forDB(where));\n};\n\n/**\n * Return string representation of class\n *\n * @override default toString method\n */\nAbstractClass.toString = function () {\n    return '[Model ' + this.modelName + ']';\n};\n\n/**\n * Save instance. When instance haven't id, create method called instead.\n * Triggers: validate, save, update | create\n * @param options {validate: true, throws: false} [optional]\n * @param callback(err, obj)\n */\nAbstractClass.prototype.save = function (options, callback) {\n\n    if (typeof options == 'function') {\n        callback = options;\n        options = {};\n    }\n\n    callback = callback || function () {};\n    options = options || {};\n\n    if (!('validate' in options)) {\n        options.validate = true;\n    }\n    if (!('throws' in options)) {\n        options.throws = false;\n    }\n\n    var inst = this;\n    var data = inst.toObject(true);\n    var Model = this.constructor;\n    var modelName = Model.modelName;\n\n    if (!this.id) {\n        // Pass options and this to create\n        data = {\n            data: this,\n            options: options\n        };\n        return Model.create(data, callback);\n    }\n\n    // validate first\n    if (!options.validate) {\n        return save();\n    }\n\n    inst.isValid(function (err, valid) {\n        if (valid) {\n            return save();\n        }\n        err = err || new ValidationError(inst);\n        // throws option is dangerous for async usage\n        if (options.throws) {\n            throw err;\n        }\n        callback.call(inst, err);\n    }, data);\n\n    // then save\n    function save() {\n        inst.trigger('save', function (saveDone) {\n            inst.trigger('update', function (updateDone) {\n                inst._adapter().save(modelName, inst.constructor._forDB(data), function (err) {\n                    if (err) {\n                        return callback(err, inst);\n                    }\n                    inst._initProperties(data, false);\n                    updateDone.call(inst, function () {\n                        saveDone.call(inst, function () {\n                            callback.call(inst, err, inst);\n                        });\n                    });\n                });\n            }, data, callback);\n        }, data, callback);\n    }\n};\n\nAbstractClass.prototype.isNewRecord = function () {\n    return !this.id;\n};\n\n/**\n * Return adapter of current record\n * @private\n */\nAbstractClass.prototype._adapter = function () {\n    return this.schema.adapter;\n};\n\n/**\n * Convert instance to Object\n *\n * @param {Boolean} onlySchema - restrict properties to schema only, default false\n * when onlySchema == true, only properties defined in schema returned,\n * otherwise all enumerable properties returned.\n * @param {Boolean} cachedRelations - include cached relations to object, only\n * taken into account when onlySchema is false.\n * @returns {Object} - canonical object representation (no getters and setters).\n */\nAbstractClass.prototype.toObject = function (onlySchema, cachedRelations) {\n    var data = {};\n    var ds = this.constructor.schema.definitions[this.constructor.modelName];\n    var properties = ds.properties;\n    var self = this;\n\n    this.constructor.forEachProperty(function (attr) {\n        if (self[attr] instanceof List) {\n            data[attr] = self[attr].toObject();\n        } else if (self.__data.hasOwnProperty(attr)) {\n            data[attr] = self[attr];\n        } else {\n            data[attr] = null;\n        }\n    });\n\n    if (!onlySchema) {\n        Object.keys(self).forEach(function (attr) {\n            if (!data.hasOwnProperty(attr)) {\n                data[attr] = self[attr];\n            }\n        });\n\n        if (cachedRelations === true && this.__cachedRelations) {\n            var relations = this.__cachedRelations;\n            Object.keys(relations).forEach(function (attr) {\n                if (!data.hasOwnProperty(attr)) {\n                    data[attr] = relations[attr];\n                }\n            });\n        }\n    }\n\n    return data;\n};\n\n// AbstractClass.prototype.hasOwnProperty = function (prop) {\n//     return this.__data && this.__data.hasOwnProperty(prop) ||\n//         Object.getOwnPropertyNames(this).indexOf(prop) !== -1;\n// };\n\nAbstractClass.prototype.toJSON = function () {\n    return this.toObject(false, true);\n};\n\n\n/**\n * Delete object from persistence\n *\n * @triggers `destroy` hook (async) before and after destroying object\n */\nAbstractClass.prototype.destroy = function (cb) {\n\n    this.trigger('destroy', function (destroyed) {\n        this._adapter().destroy(this.constructor.modelName, this.id, function (err) {\n            if (err) {\n                return cb(err);\n            }\n\n            destroyed(function () {\n                if(cb) cb();\n            });\n        }.bind(this));\n    }, this.toObject(), cb);\n};\n\n/**\n * Update single attribute\n *\n * equals to `updateAttributes({name: value}, cb)\n *\n * @param {String} name - name of property\n * @param {Mixed} value - value of property\n * @param {Function} callback - callback called with (err, instance)\n */\nAbstractClass.prototype.updateAttribute = function updateAttribute(name, value, callback) {\n    var data = {};\n    data[name] = value;\n    this.updateAttributes(data, callback);\n};\n\n/**\n * Update set of attributes\n *\n * this method performs validation before updating\n *\n * @trigger `validation`, `save` and `update` hooks\n * @param {Object} data - data to update\n * @param {Function} callback - callback called with (err, instance)\n */\nAbstractClass.prototype.updateAttributes = function updateAttributes(data, callback) {\n\n    var inst = this;\n    var modelName = this.constructor.modelName;\n\n    if (typeof data === 'function') {\n        callback = data;\n        data = null;\n    }\n\n    if (!data) {\n        data = {};\n    }\n\n    // update instance's properties\n    Object.keys(data).forEach(function (key) {\n        inst[key] = data[key];\n    });\n\n    inst.isValid(function (err, valid) {\n        if (!valid) {\n            err = err || new ValidationError(inst);\n            if (callback) {\n                callback.call(inst, err);\n            }\n        } else {\n            inst.trigger('save', function (saveDone) {\n                inst.trigger('update', function (done) {\n\n                    Object.keys(data).forEach(function (key) {\n                        inst[key] = data[key];\n                    });\n\n                    inst._adapter().updateAttributes(modelName, inst.id, inst.constructor._forDB(inst.toObject(true)), function (err) {\n                        if (!err) {\n                            // update _was attrs\n                            Object.keys(data).forEach(function (key) {\n                                inst.__dataWas[key] = inst.__data[key];\n                            });\n                        }\n                        done.call(inst, function () {\n                            saveDone.call(inst, function () {\n                                if (callback) {\n                                    callback.call(inst, err, inst);\n                                }\n                            });\n                        });\n                    });\n                }, data, callback);\n            }, data, callback);\n        }\n    }, data);\n};\n\nAbstractClass.prototype.fromObject = function (obj) {\n    Object.keys(obj).forEach(function (key) {\n        this[key] = obj[key];\n    }.bind(this));\n};\n\n/**\n * Checks is property changed based on current property and initial value\n *\n * @param {String} attr - property name\n * @return Boolean\n */\nAbstractClass.prototype.propertyChanged = function propertyChanged(attr) {\n    return this.__data[attr] !== this.__dataWas[attr];\n};\n\n/**\n * Reload object from persistence\n *\n * @requires `id` member of `object` to be able to call `find`\n * @param {Function} callback - called with (err, instance) arguments\n */\nAbstractClass.prototype.reload = function reload(callback) {\n\n    this.constructor.find(this.id, callback);\n};\n\n/**\n * Reset dirty attributes\n *\n * this method does not perform any database operation it just reset object to it's\n * initial state\n */\nAbstractClass.prototype.reset = function () {\n    var obj = this;\n    Object.keys(obj).forEach(function (k) {\n        if (k !== 'id' && !obj.constructor.schema.definitions[obj.constructor.modelName].properties[k]) {\n            delete obj[k];\n        }\n        if (obj.propertyChanged(k)) {\n            obj[k] = obj[k + '_was'];\n        }\n    });\n};\n\nAbstractClass.prototype.inspect = function () {\n    return util.inspect(this.__data, false, 4, true);\n};\n\npromisedClassMethods.forEach(function(methodName) {\n    AbstractClass[methodName] = wrapWithPromise(AbstractClass[methodName], true);\n});\n\npromisedInstanceMethods.forEach(function(methodName) {\n    AbstractClass.prototype[methodName] = wrapWithPromise(AbstractClass.prototype[methodName]);\n});\n\nfunction wrapWithPromise(fn, isClassMethod) {\n    return function promisedWrap() {\n        var args = [].slice.call(arguments);\n        var callback = 'function' === typeof args[args.length - 1] ? args.pop() : null;\n        var self = this;\n        var Model = isClassMethod ? self : self.constructor;\n        var queryResult;\n        var promisedQuery = connection(Model.schema)\n        .then(function() {\n            return new when.Promise(function(resolve, reject) {\n                args.push(function(err, result) {\n                    queryResult = result;\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(result);\n                    }\n                });\n                fn.apply(self, args);\n            });\n        });\n        if (callback) {\n            promisedQuery.then(function(result) {\n                callback(null, result);\n            }, function(err) {\n                if ('undefined' !== queryResult) {\n                    callback(err, queryResult);\n                } else {\n                    callback(err);\n                }\n            });\n        } else {\n            return promisedQuery;\n        }\n    };\n}\n\n/**\n * Check whether `s` is not undefined\n * @param {Mixed} s\n * @return {Boolean} s is undefined\n */\nfunction isdef(s) {\n    var undef;\n    return s !== undef;\n}\n\n/**\n * Define readonly property on object\n *\n * @param {Object} obj\n * @param {String} key\n * @param {Mixed} value\n */\nfunction defineReadonlyProp(obj, key, value) {\n    Object.defineProperty(obj, key, {\n        writable: false,\n        enumerable: true,\n        configurable: true,\n        value: value\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-jugglingdb/node_modules/jugglingdb/lib/validations.js":"/**\n * Module exports\n */\nexports.ValidationError = ValidationError;\n\n/**\n * Validation mixins for model.js\n *\n * Basically validation configurators is just class methods, which adds validations\n * configs to AbstractClass._validations. Each of this validations run when\n * `obj.isValid()` method called.\n *\n * Each configurator can accept n params (n-1 field names and one config). Config\n * is {Object} depends on specific validation, but all of them has one common part:\n * `message` member. It can be just string, when only one situation possible,\n * e.g. `Post.validatesPresenceOf('title', { message: 'can not be blank' });`\n *\n * In more complicated cases it can be {Hash} of messages (for each case):\n * `User.validatesLengthOf('password', { min: 6, max: 20, message: {min: 'too short', max: 'too long'}});`\n */\nvar Validatable = require('./model.js');\n\n/**\n * Validate presence. This validation fails when validated field is blank.\n *\n * Default error message \"can't be blank\"\n *\n * @example presence of title\n * ```\n * Post.validatesPresenceOf('title');\n * ```\n * @example with custom message\n * ```\n * Post.validatesPresenceOf('title', {message: 'Can not be blank'});\n * ```\n *\n * @sync\n *\n * @nocode\n * @see helper/validatePresence\n */\nValidatable.validatesPresenceOf = getConfigurator('presence');\n\n/**\n * Validate length. Three kinds of validations: min, max, is.\n *\n * Default error messages:\n *\n * - min: too short\n * - max: too long\n * - is:  length is wrong\n *\n * @example length validations\n * ```\n * User.validatesLengthOf('password', {min: 7});\n * User.validatesLengthOf('email', {max: 100});\n * User.validatesLengthOf('state', {is: 2});\n * User.validatesLengthOf('nick', {min: 3, max: 15});\n * ```\n * @example length validations with custom error messages\n * ```\n * User.validatesLengthOf('password', {min: 7, message: {min: 'too weak'}});\n * User.validatesLengthOf('state', {is: 2, message: {is: 'is not valid state name'}});\n * ```\n *\n * @sync\n * @nocode\n * @see helper/validateLength\n */\nValidatable.validatesLengthOf = getConfigurator('length');\n\n/**\n * Validate numericality.\n *\n * @example\n * ```\n * User.validatesNumericalityOf('age', { message: { number: '...' }});\n * User.validatesNumericalityOf('age', {int: true, message: { int: '...' }});\n * ```\n *\n * Default error messages:\n *\n * - number: is not a number\n * - int: is not an integer\n *\n * @sync\n * @nocode\n * @see helper/validateNumericality\n */\nValidatable.validatesNumericalityOf = getConfigurator('numericality');\n\n/**\n * Validate inclusion in set\n *\n * @example\n * ```\n * User.validatesInclusionOf('gender', {in: ['male', 'female']});\n * User.validatesInclusionOf('role', {\n *     in: ['admin', 'moderator', 'user'], message: 'is not allowed'\n * });\n * ```\n *\n * Default error message: is not included in the list\n *\n * @sync\n * @nocode\n * @see helper/validateInclusion\n */\nValidatable.validatesInclusionOf = getConfigurator('inclusion');\n\n/**\n * Validate exclusion\n *\n * @example `Company.validatesExclusionOf('domain', {in: ['www', 'admin']});`\n *\n * Default error message: is reserved\n *\n * @nocode\n * @see helper/validateExclusion\n */\nValidatable.validatesExclusionOf = getConfigurator('exclusion');\n\n/**\n * Validate format\n *\n * Default error message: is invalid\n *\n * @nocode\n * @see helper/validateFormat\n */\nValidatable.validatesFormatOf = getConfigurator('format');\n\n/**\n * Validate using custom validator\n *\n * Default error message: is invalid\n *\n * Example:\n *\n *     User.validate('name', customValidator, {message: 'Bad name'});\n *     function customValidator(err) {\n *         if (this.name === 'bad') err();\n *     });\n *     var user = new User({name: 'Peter'});\n *     user.isValid(); // true\n *     user.name = 'bad';\n *     user.isValid(); // false\n *\n * @nocode\n * @see helper/validateCustom\n */\nValidatable.validate = getConfigurator('custom');\n\n/**\n * Validate using custom async validator\n *\n * Default error message: is invalid\n *\n * Example:\n *\n *     User.validateAsync('name', customValidator, {message: 'Bad name'});\n *     function customValidator(err, done) {\n *         process.nextTick(function () {\n *             if (this.name === 'bad') err();\n *             done();\n *         });\n *     });\n *     var user = new User({name: 'Peter'});\n *     user.isValid(); // false (because async validation setup)\n *     user.isValid(function (isValid) {\n *         isValid; // true\n *     })\n *     user.name = 'bad';\n *     user.isValid(); // false\n *     user.isValid(function (isValid) {\n *         isValid; // false\n *     })\n *\n * @async\n * @nocode\n * @see helper/validateCustom\n */\nValidatable.validateAsync = getConfigurator('custom', {async: true});\n\n/**\n * Validate uniqueness\n *\n * Default error message: is not unique\n *\n * @async\n * @nocode\n * @see helper/validateUniqueness\n */\nValidatable.validatesUniquenessOf = getConfigurator('uniqueness', {async: true});\n\n// implementation of validators\n\n/**\n * Presence validator\n */\nfunction validatePresence(attr, conf, err) {\n    if (blank(this[attr])) {\n        err();\n    }\n}\n\n/**\n * Length validator\n */\nfunction validateLength(attr, conf, err) {\n    if (nullCheck.call(this, attr, conf, err)) return;\n\n    var len = this[attr].length;\n    if (conf.min && len < conf.min) {\n        err('min');\n    }\n    if (conf.max && len > conf.max) {\n        err('max');\n    }\n    if (conf.is && len !== conf.is) {\n        err('is');\n    }\n}\n\n/**\n * Numericality validator\n */\nfunction validateNumericality(attr, conf, err) {\n    if (nullCheck.call(this, attr, conf, err)) return;\n\n    if (typeof this[attr] !== 'number') {\n        return err('number');\n    }\n    if (conf.int && this[attr] !== Math.round(this[attr])) {\n        return err('int');\n    }\n}\n\n/**\n * Inclusion validator\n */\nfunction validateInclusion(attr, conf, err) {\n    if (nullCheck.call(this, attr, conf, err)) return;\n\n    if (!~conf.in.indexOf(this[attr])) {\n        err();\n    }\n}\n\n/**\n * Exclusion validator\n */\nfunction validateExclusion(attr, conf, err) {\n    if (nullCheck.call(this, attr, conf, err)) return;\n\n    if (~conf.in.indexOf(this[attr])) {\n        err();\n    }\n}\n\n/**\n * Format validator\n */\nfunction validateFormat(attr, conf, err) {\n    if (nullCheck.call(this, attr, conf, err)) return;\n\n    if (typeof this[attr] === 'string') {\n        if (!this[attr].match(conf['with'])) {\n            err();\n        }\n    } else {\n        err();\n    }\n}\n\n/**\n * Custom validator\n */\nfunction validateCustom(attr, conf, err, done) {\n    conf.customValidator.call(this, err, done);\n}\n\n/**\n * Uniqueness validator\n */\nfunction validateUniqueness(attr, conf, err, done) {\n    if (nullCheck.call(this, attr, conf, err)) {\n        return done();\n    }\n\n    var cond = {where: {}};\n    cond.where[attr] = this[attr];\n    this.constructor.all(cond, function (error, found) {\n        if (error) {\n            return err();\n        }\n        if (found.length > 1) {\n            err();\n        } else if (found.length === 1 && (!this.id || !found[0].id || found[0].id.toString() != this.id.toString())) {\n            err();\n        }\n        done();\n    }.bind(this));\n}\n\nvar validators = {\n    presence:     validatePresence,\n    length:       validateLength,\n    numericality: validateNumericality,\n    inclusion:    validateInclusion,\n    exclusion:    validateExclusion,\n    format:       validateFormat,\n    custom:       validateCustom,\n    uniqueness:   validateUniqueness\n};\n\nfunction getConfigurator(name, opts) {\n    return function () {\n        configure(this, name, arguments, opts);\n    };\n}\n\n/**\n * This method performs validation, triggers validation hooks.\n * Before validation `obj.errors` collection cleaned.\n * Each validation can add errors to `obj.errors` collection.\n * If collection is not blank, validation failed.\n *\n * @warning This method can be called as sync only when no async validation\n * configured. It's strongly recommended to run all validations as asyncronous.\n *\n * @param {Function} callback called with (valid)\n * @return {Boolean} true if no async validation configured and all passed\n *\n * @example ExpressJS controller: render user if valid, show flash otherwise\n * ```\n * user.isValid(function (valid) {\n *     if (valid) res.render({user: user});\n *     else res.flash('error', 'User is not valid'), console.log(user.errors), res.redirect('/users');\n * });\n *\n * // when the callback needs two arguments,\n * // the first argument is the validation errors,\n * // or error from `beforeValidate/afterValidate` hook\n * user.isValid(function (error, isValid) {\n *     error; // error from `beforeValidate`, mostly `null`\n * })\n * ```\n */\nValidatable.prototype.isValid = function (callback, data) {\n    var valid = true, inst = this, wait = 0, async = false;\n\n    callback = callback || NOOP;\n\n    // callback only needs one arguments, then the signature is `callback(valid)`\n    // convert it to standard node.js callback style\n    if (callback.length < 2) {\n        var _callback = callback;\n        callback = function (err, valid) {\n            _callback(valid);\n        };\n    }\n\n    // exit with success when no errors\n    if (!this.constructor._validations) {\n        cleanErrors(this);\n        if (callback) {\n            this.trigger('validate', function(validationsDone) {\n                validationsDone.call(inst, function() {\n                    callback(null, valid);\n                });\n            }, data, function (err) {\n                callback(err, false);\n            });\n        }\n        return valid;\n    }\n\n    Object.defineProperty(this, 'errors', {\n        enumerable: false,\n        configurable: true,\n        value: new Errors(this)\n    });\n\n    this.trigger('validate', function (validationsDone) {\n        var inst = this,\n            asyncFail = false;\n\n        this.constructor._validations.forEach(function (v) {\n            if (v[2] && v[2].async) {\n                async = true;\n                wait += 1;\n                process.nextTick(function () {\n                    validationFailed(inst, v, done);\n                });\n            } else {\n                if (validationFailed(inst, v)) {\n                    valid = false;\n                }\n            }\n\n        });\n\n        if (!async) {\n            validationsDone.call(inst, function() {\n                if (valid) cleanErrors(inst);\n                if (callback) {\n                    callback(valid ? null : new ValidationError(this), valid);\n                }\n            });\n        }\n\n        function done(fail) {\n            asyncFail = asyncFail || fail;\n            if (--wait === 0) {\n                validationsDone.call(inst, function () {\n                    if (valid && !asyncFail) cleanErrors(inst);\n                    if (callback) {\n                        callback(valid ? null : new ValidationError(this), valid && !asyncFail);\n                    }\n                });\n            }\n        }\n\n    }, data, function (err) {\n        callback(err, false);\n    });\n\n    if (async) {\n        // in case of async validation we should return undefined here,\n        // because not all validations are finished yet\n        return;\n    } else {\n        return valid;\n    }\n\n};\n\nfunction cleanErrors(inst) {\n    Object.defineProperty(inst, 'errors', {\n        enumerable: false,\n        configurable: true,\n        value: null\n    });\n}\n\nfunction validationFailed(inst, v, cb) {\n    var attr = v[0];\n    var conf = v[1];\n    var opts = v[2] || {};\n\n    if (typeof attr !== 'string') return false;\n\n    // here we should check skip validation conditions (if, unless)\n    // that can be specified in conf\n    if (skipValidation(inst, conf, 'if')) return false;\n    if (skipValidation(inst, conf, 'unless')) return false;\n\n    var fail = false;\n    var validator = validators[conf.validation];\n    var validatorArguments = [];\n    validatorArguments.push(attr);\n    validatorArguments.push(conf);\n    validatorArguments.push(function onerror(kind) {\n        var message, code = conf.validation;\n        if (conf.message) {\n            message = conf.message;\n        }\n        if (!message && defaultMessages[conf.validation]) {\n            message = defaultMessages[conf.validation];\n        }\n        if (!message) {\n            message = 'is invalid';\n        }\n        if (kind) {\n            code += '.' + kind;\n            if (message[kind]) {\n                // get deeper\n                message = message[kind];\n            } else if (defaultMessages.common[kind]) {\n                message = defaultMessages.common[kind];\n            } else {\n                message = 'is invalid';\n            }\n        }\n        inst.errors.add(attr, message, code);\n        fail = true;\n    });\n    if (cb) {\n        validatorArguments.push(function () {\n            cb(fail);\n        });\n    }\n    validator.apply(inst, validatorArguments);\n    return fail;\n}\n\nfunction skipValidation(inst, conf, kind) {\n    var doValidate = true;\n    if (typeof conf[kind] === 'function') {\n        doValidate = conf[kind].call(inst);\n        if (kind === 'unless') doValidate = !doValidate;\n    } else if (typeof conf[kind] === 'string') {\n        if (typeof inst[conf[kind]] === 'function') {\n            doValidate = inst[conf[kind]].call(inst);\n            if (kind === 'unless') doValidate = !doValidate;\n        } else if (inst.__data.hasOwnProperty(conf[kind])) {\n            doValidate = inst[conf[kind]];\n            if (kind === 'unless') doValidate = !doValidate;\n        } else {\n            doValidate = kind === 'if';\n        }\n    }\n    return !doValidate;\n}\n\nvar defaultMessages = {\n    presence: 'can\\'t be blank',\n    length: {\n        min: 'too short',\n        max: 'too long',\n        is: 'length is wrong'\n    },\n    common: {\n        blank: 'is blank',\n        'null': 'is null'\n    },\n    numericality: {\n        'int': 'is not an integer',\n        'number': 'is not a number'\n    },\n    inclusion: 'is not included in the list',\n    exclusion: 'is reserved',\n    uniqueness: 'is not unique'\n};\n\nfunction nullCheck(attr, conf, err) {\n    var isNull = this[attr] === null || !(attr in this);\n    if (isNull) {\n        if (!conf.allowNull) {\n            err('null');\n        }\n        return true;\n    } else {\n        if (blank(this[attr])) {\n            if (!conf.allowBlank) {\n                err('blank');\n            }\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Return true when v is undefined, blank array, null or empty string\n * otherwise returns false\n *\n * @param {Mix} v\n * @returns {Boolean} whether `v` blank or not\n */\nfunction blank(v) {\n    if (typeof v === 'undefined') return true;\n    if (v instanceof Array && v.length === 0) return true;\n    if (v === null) return true;\n    if (typeof v == 'string' && v === '') return true;\n    return false;\n}\n\nfunction configure(cls, validation, args, opts) {\n    if (!cls._validations) {\n        Object.defineProperty(cls, '_validations', {\n            writable: true,\n            configurable: true,\n            enumerable: false,\n            value: []\n        });\n    }\n    args = [].slice.call(args);\n    var conf;\n    if (typeof args[args.length - 1] === 'object') {\n        conf = args.pop();\n    } else {\n        conf = {};\n    }\n    if (validation === 'custom' && typeof args[args.length - 1] === 'function') {\n        conf.customValidator = args.pop();\n    }\n    conf.validation = validation;\n    args.forEach(function (attr) {\n        cls._validations.push([attr, conf, opts]);\n    });\n}\n\nfunction Errors(obj) {\n    Object.defineProperty(this, '__codes', {\n        enumerable: false,\n        configurable: true,\n        value: {}\n    });\n\n    Object.defineProperty(this, '__obj', {\n        enumerable: false,\n        configurable: true,\n        value: obj\n    });\n}\n\nErrors.prototype.add = function (field, message, code) {\n    code = code || 'invalid';\n    if (!this[field]) {\n        this[field] = [];\n        this.__codes[field] = [];\n    }\n    this[field].push(message);\n    this.__codes[field].push(code);\n};\n\nErrors.prototype.__localize = function localize(locale) {\n    var errors = this, result = {}, i18n, v, codes = this.__codes;\n    i18n = this.__obj.constructor.i18n;\n    v = i18n && i18n[locale] && i18n[locale].validation;\n    Object.keys(codes).forEach(function(prop) {\n        result[prop] = codes[prop].map(function(code, i) {\n            return v && v[prop] && v[prop][code] || errors[prop][i];\n        });\n    });\n    return result;\n};\n\nfunction ErrorCodes(messages) {\n    var c = this;\n    Object.keys(messages).forEach(function(field) {\n        c[field] = messages[field].__codes;\n    });\n}\n\nfunction ValidationError(obj) {\n    if (!(this instanceof ValidationError)) return new ValidationError(obj);\n\n    this.name = 'ValidationError';\n    this.message = 'Validation error';\n    this.statusCode = 400;\n    this.codes = obj.errors && obj.errors.__codes;\n    this.context = obj && obj.constructor && obj.constructor.modelName;\n\n    Error.call(this);\n}\n\n\nfunction NOOP(error, result) {}\n\nValidationError.prototype.__proto__ = Error.prototype;\n","/home/travis/build/npmtest/node-npmtest-jugglingdb/node_modules/jugglingdb/lib/list.js":"var util = require('util');\n\nmodule.exports = List;\n\n/**\n * List class provides functionality of nested collection\n *\n * @param {Array} data - array of items.\n * @param {Crap} type - array with some type information? TODO: rework this API.\n * @param {AbstractClass} parent - owner of list.\n * @constructor\n */\nfunction List(data, type, parent) {\n    var list = this;\n    if (!(list instanceof List)) {\n        return new List(data);\n    }\n\n    if (data && data instanceof List) data = data.items;\n\n    Object.defineProperty(list, 'parent', {\n        writable: false,\n        enumerable: false,\n        configurable: false,\n        value: parent\n    });\n\n    Object.defineProperty(list, 'nextid', {\n        writable: true,\n        enumerable: false,\n        value: 1\n    });\n\n    var Item = ListItem;\n    if (typeof type === 'object' && type.constructor.name === 'Array') {\n        Item = type[0] || ListItem;\n    }\n\n    data = list.items = data || [];\n    Object.defineProperty(list, 'ItemType', {\n        writable: true,\n        enumerable: false,\n        configurable: true,\n        value: Item\n    });\n\n    if ('string' === typeof data) {\n        try {\n            list.items = data = JSON.parse(data);\n        } catch(e) {\n            list.items = data = [];\n        }\n    }\n\n    data.forEach(function(item, i) {\n        data[i] = new Item(item, list);\n        Object.defineProperty(list, data[i].id, {\n            writable: true,\n            enumerable: false,\n            configurable: true,\n            value: data[i]\n        });\n        if (list.nextid <= data[i].id) {\n            list.nextid = data[i].id + 1;\n        }\n    });\n\n    Object.defineProperty(list, 'length', {\n        enumerable: false,\n        configurable: true,\n        get: function() {\n            return list.items.length;\n        }\n    });\n\n    return list;\n\n}\n\nList.prototype.inspect = function() {\n    return util.inspect(this.items);\n};\n\nvar _;\ntry {\n    var underscore = 'underscore';\n    _ = require(underscore);\n} catch (e) {\n    _ = false;\n}\n\nif (_) {\n    var _import = [\n        // collection methods\n        'each',\n        'map',\n        'reduce',\n        'reduceRight',\n        'find',\n        'filter',\n        'reject',\n        'all',\n        'any',\n        'include',\n        'invoke',\n        'pluck',\n        'max',\n        'min',\n        'sortBy',\n        'groupBy',\n        'sortedIndex',\n        'shuffle',\n        'toArray',\n        'size',\n        // array methods\n        'first',\n        'initial',\n        'last',\n        'rest',\n        'compact',\n        'flatten',\n        'without',\n        'union',\n        'intersection',\n        'difference',\n        'uniq',\n        'zip',\n        'indexOf',\n        'lastIndexOf',\n        'range'\n    ];\n\n    _import.forEach(function(name) {\n        List.prototype[name] = function() {\n            var args = [].slice.call(arguments);\n            args.unshift(this.items);\n            return _[name].apply(_, args);\n        };\n    });\n}\n\n// copy all array methods\n[   'concat',\n    'join',\n    'pop',\n    'push',\n    'reverse',\n    'shift',\n    'slice',\n    'sort',\n    'splice',\n    'toSource',\n    'toString',\n    'unshift',\n    'every',\n    'filter',\n    'forEach',\n    'indexOf',\n    'lastIndexOf',\n    'map',\n    'some'\n].forEach(function (method) {\n    var slice = [].slice;\n    List.prototype[method] = function () {\n        return Array.prototype[method].apply(this.items, slice.call(arguments));\n    };\n});\n\nList.prototype.find = function(pattern, field) {\n    if (!field) {\n        field = 'id';\n    }\n    var res;\n    this.items.forEach(function(o) {\n        if (o[field] == pattern) res = o;\n    });\n    return res;\n};\n\nList.prototype.removeAt = function(index) {\n    this.splice(index, 1);\n};\n\nList.prototype.toObject = function() {\n    return this.items;\n};\n\nList.prototype.toJSON = function() {\n    return this.items;\n};\n\nList.prototype.toString = function() {\n    return JSON.stringify(this.items);\n};\n\nList.prototype.autoincrement = function() {\n    return this.nextid++;\n};\n\nList.prototype.push = function(obj) {\n    var item = new ListItem(obj, this);\n    this.items.push(item);\n    return item;\n};\n\nList.prototype.remove = function(obj) {\n    var id = obj.id ? obj.id : obj;\n    var found = false;\n    this.items.forEach(function(o, i) {\n        if (id && o.id == id) {\n            found = i;\n            if (o.id !== id) {\n                console.log('WARNING! Type of id not matched');\n            }\n        }\n    });\n    if (found !== false) {\n        delete this[id];\n        this.items.splice(found, 1);\n    }\n};\n\nList.prototype.map = function(cb) {\n    if (typeof cb === 'function') {\n        return this.items.map(cb);\n    }\n    if (typeof cb === 'string') {\n        return this.items.map(function(el) {\n            if (typeof el[cb] === 'function') {\n                return el[cb]();\n            }\n            if (el.hasOwnProperty(cb)) {\n                return el[cb];\n            }\n        });\n    }\n};\n\nfunction ListItem(data, parent) {\n    if (typeof data === 'object') {\n        for (var i in data) this[i] = data[i];\n    } else {\n        this.id = data;\n    }\n    Object.defineProperty(this, 'parent', {\n        writable: false,\n        enumerable: false,\n        configurable: true,\n        value: parent\n    });\n    if (!this.id) {\n        this.id = parent.autoincrement();\n    }\n    if (parent.ItemType) {\n        this.__proto__ = parent.ItemType.prototype;\n        if (parent.ItemType !== ListItem) {\n            parent.ItemType.apply(this);\n        }\n    }\n\n}\n\nListItem.prototype.save = function save() {\n    this.parent.parent.save();\n};\n\n","/home/travis/build/npmtest/node-npmtest-jugglingdb/node_modules/jugglingdb/lib/hooks.js":"/**\n * Module exports\n */\nexports.Hookable = Hookable;\n\n/**\n * Hooks mixins for ./model.js\n */\nvar Hookable = require('./model.js');\n\n/**\n * List of hooks available\n */\nHookable.afterInitialize = null;\nHookable.beforeValidate = null;\nHookable.afterValidate = null;\nHookable.beforeSave = null;\nHookable.afterSave = null;\nHookable.beforeCreate = null;\nHookable.afterCreate = null;\nHookable.beforeUpdate = null;\nHookable.afterUpdate = null;\nHookable.beforeDestroy = null;\nHookable.afterDestroy = null;\n\nHookable.prototype.trigger = function trigger(actionName, work, data, quit) {\n    var capitalizedName = capitalize(actionName);\n    var beforeHook = this.constructor[\"before\" + capitalizedName];\n    var afterHook = this.constructor[\"after\" + capitalizedName];\n    if (actionName === 'validate') {\n        beforeHook = beforeHook || this.constructor.beforeValidation;\n        afterHook = afterHook || this.constructor.afterValidation;\n    }\n    var inst = this;\n\n    // we only call \"before\" hook when we have actual action (work) to perform\n    if (work) {\n        if (beforeHook) {\n            // before hook should be called on instance with one param: callback\n            beforeHook.call(inst, function (err) {\n                if (err) {\n                    if (quit) {\n                        quit.call(inst, err);\n                    }\n                    return;\n                }\n                // actual action also have one param: callback\n                work.call(inst, next);\n            }, data);\n        } else {\n            work.call(inst, next);\n        }\n    } else {\n        next();\n    }\n\n    function next(done) {\n        if (afterHook) {\n            afterHook.call(inst, done);\n        } else if (done) {\n            done.call(this);\n        }\n    }\n};\n\nfunction capitalize(string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n}\n","/home/travis/build/npmtest/node-npmtest-jugglingdb/node_modules/jugglingdb/lib/relations.js":"/**\n * Dependencies\n */\nvar i8n = require('inflection');\nvar defineScope = require('./scope.js').defineScope;\n\n/**\n * Relations mixins for ./model.js\n */\nvar Model = require('./model.js');\n\nModel.relationNameFor = function relationNameFor(foreignKey) {\n    for (var rel in this.relations) {\n        if (this.relations[rel].type === 'belongsTo' && this.relations[rel].keyFrom === foreignKey) {\n            return rel;\n        }\n    }\n};\n\n/**\n * Declare hasMany relation\n *\n * @param {Model} anotherClass - class to has many\n * @param {Object} params - configuration {as:, foreignKey:}\n * @example `User.hasMany(Post, {as: 'posts', foreignKey: 'authorId'});`\n */\nModel.hasMany = function hasMany(anotherClass, params) {\n    var thisClass = this, thisClassName = this.modelName;\n    params = params || {};\n    if (typeof anotherClass === 'string') {\n        params.as = anotherClass;\n        if (params.model) {\n            anotherClass = params.model;\n        } else {\n            var anotherClassName = i8n.singularize(anotherClass).toLowerCase();\n            for(var name in this.schema.models) {\n                if (name.toLowerCase() === anotherClassName) {\n                    anotherClass = this.schema.models[name];\n                }\n            }\n        }\n    }\n    var methodName = params.as ||\n        i8n.camelize(i8n.pluralize(anotherClass.modelName), true);\n    var fk = params.foreignKey || i8n.camelize(thisClassName + '_id', true);\n\n    this.relations[methodName] = {\n        type: 'hasMany',\n        keyFrom: 'id',\n        keyTo: fk,\n        modelTo: anotherClass,\n        multiple: true\n    };\n    // each instance of this class should have method named\n    // pluralize(anotherClass.modelName)\n    // which is actually just anotherClass.all({where: {thisModelNameId: this.id}}, cb);\n    var scopeMethods = {\n        find: find,\n        destroy: destroy\n    };\n    if (params.through) {\n\n        // Append through relation, like modelTo\n        this.relations[methodName].modelThrough = params.through;\n\n        var fk2 = i8n.camelize(anotherClass.modelName + '_id', true);\n        scopeMethods.create = function create(data, done) {\n            if (typeof data !== 'object') {\n                done = data;\n                data = {};\n            }\n            if ('function' !== typeof done) {\n                done = function() {};\n            }\n            var self = this;\n            var id = this.id;\n            anotherClass.create(data, function(err, ac) {\n                if (err) return done(err, ac);\n                var d = {};\n                d[params.through.relationNameFor(fk)] = self;\n                d[params.through.relationNameFor(fk2)] = ac;\n                params.through.create(d, function(e) {\n                    if (e) {\n                        ac.destroy(function() {\n                            done(e);\n                        });\n                    } else {\n                        done(err, ac);\n                    }\n                });\n            });\n        };\n        scopeMethods.add = function(acInst, data, done) {\n            if (typeof data === 'function') {\n                done = data;\n                data = {};\n            }\n            var query = {};\n            query[fk] = this.id;\n            data[params.through.relationNameFor(fk)] = this;\n            query[fk2] = acInst.id || acInst;\n            data[params.through.relationNameFor(fk2)] = acInst;\n            params.through.findOrCreate({where: query}, data, done);\n        };\n        scopeMethods.remove = function(acInst, done) {\n            var q = {};\n            q[fk] = this.id;\n            q[fk2] = acInst.id || acInst;\n            params.through.findOne({where: q}, function(err, d) {\n                if (err) {\n                    return done(err);\n                }\n                if (!d) {\n                    return done();\n                }\n                d.destroy(done);\n            });\n        };\n        delete scopeMethods.destroy;\n    }\n    defineScope(this.prototype, params.through || anotherClass, methodName, function () {\n        var filter = {};\n        filter.where = {};\n        filter.where[fk] = this.id;\n        if (params.through) {\n            filter.collect = i8n.camelize(anotherClass.modelName, true);\n            filter.include = filter.collect;\n        }\n        return filter;\n    }, scopeMethods);\n\n    if (!params.through) {\n        // obviously, anotherClass should have attribute called `fk`\n        anotherClass.schema.defineForeignKey(anotherClass.modelName, fk, this.modelName);\n    }\n\n    function find(id, cb) {\n        anotherClass.find(id, function (err, inst) {\n            if (err) return cb(err);\n            if (!inst) return cb(new Error('Not found'));\n            if (inst[fk] && inst[fk].toString() == this.id.toString()) {\n                cb(null, inst);\n            } else {\n                cb(new Error('Permission denied'));\n            }\n        }.bind(this));\n    }\n\n    function destroy(id, cb) {\n        var self = this;\n        anotherClass.find(id, function (err, inst) {\n            if (err) return cb(err);\n            if (!inst) return cb(new Error('Not found'));\n            if (inst[fk] && inst[fk].toString() == self.id.toString()) {\n                inst.destroy(cb);\n            } else {\n                cb(new Error('Permission denied'));\n            }\n        });\n    }\n\n};\n\n/**\n * Declare belongsTo relation\n *\n * @param {Class} anotherClass - class to belong\n * @param {Object} params - configuration {as: 'propertyName', foreignKey: 'keyName'}\n *\n * **Usage examples**\n * Suppose model Post have a *belongsTo* relationship with User (the author of the post). You could declare it this way:\n * Post.belongsTo(User, {as: 'author', foreignKey: 'userId'});\n *\n * When a post is loaded, you can load the related author with:\n * post.author(function(err, user) {\n *     // the user variable is your user object\n * });\n *\n * The related object is cached, so if later you try to get again the author, no additional request will be made.\n * But there is an optional boolean parameter in first position that set whether or not you want to reload the cache:\n * post.author(true, function(err, user) {\n *     // The user is reloaded, even if it was already cached.\n * });\n *\n * This optional parameter default value is false, so the related object will be loaded from cache if available.\n */\nModel.belongsTo = function (anotherClass, params) {\n    params = params || {};\n    if ('string' === typeof anotherClass) {\n        params.as = anotherClass;\n        if (params.model) {\n            anotherClass = params.model;\n        } else {\n            var anotherClassName = anotherClass.toLowerCase();\n            for(var name in this.schema.models) {\n                if (name.toLowerCase() === anotherClassName) {\n                    anotherClass = this.schema.models[name];\n                }\n            }\n        }\n    }\n    var methodName = params.as || i8n.camelize(anotherClass.modelName, true);\n    var fk = params.foreignKey || methodName + 'Id';\n\n    this.relations[methodName] = {\n        type: 'belongsTo',\n        keyFrom: fk,\n        keyTo: 'id',\n        modelTo: anotherClass,\n        multiple: false\n    };\n\n    this.schema.defineForeignKey(this.modelName, fk, anotherClass.modelName);\n    this.prototype.__finders__ = this.prototype.__finders__ || {};\n\n    this.prototype.__finders__[methodName] = function (id, cb) {\n        if (id === null) {\n            cb(null, null);\n            return;\n        }\n        anotherClass.find(id, function (err,inst) {\n            if (err) {\n                return cb(err);\n            }\n            if (!inst) {\n                return cb(null, null);\n            }\n            if (inst.id.toString() === this[fk].toString()) {\n                cb(null, inst);\n            } else {\n                cb(new Error('Permission denied'));\n            }\n        }.bind(this));\n    };\n\n    this.prototype[methodName] = function (refresh, p) {\n        if (arguments.length === 1) {\n            p = refresh;\n            refresh = false;\n        } else if (arguments.length > 2) {\n            throw new Error('Method can\\'t be called with more than two arguments');\n        }\n        var self = this;\n        var cachedValue;\n        if (!refresh && this.__cachedRelations && (typeof this.__cachedRelations[methodName] !== 'undefined')) {\n            cachedValue = this.__cachedRelations[methodName];\n        }\n        if (p instanceof Model) { // acts as setter\n            this[fk] = p.id;\n            this.__cachedRelations[methodName] = p;\n        } else if (typeof p === 'function') { // acts as async getter\n            if (typeof cachedValue === 'undefined') {\n                this.__finders__[methodName].apply(self, [this[fk], function(err, inst) {\n                    if (!err) {\n                        self.__cachedRelations[methodName] = inst;\n                    }\n                    p(err, inst);\n                }]);\n                return this[fk];\n            } else {\n                p(null, cachedValue);\n                return cachedValue;\n            }\n        } else if (typeof p === 'undefined') { // acts as sync getter\n            return this[fk];\n        } else { // setter\n            this[fk] = p;\n            delete this.__cachedRelations[methodName];\n        }\n    };\n\n};\n\n/**\n * Many-to-many relation\n *\n * Post.hasAndBelongsToMany('tags'); creates connection model 'PostTag'\n */\nModel.hasAndBelongsToMany = function hasAndBelongsToMany(anotherClass, params) {\n    params = params || {};\n    var models = this.schema.models;\n\n    if ('string' === typeof anotherClass) {\n        params.as = anotherClass;\n        if (params.model) {\n            anotherClass = params.model;\n        } else {\n            anotherClass = lookupModel(i8n.singularize(anotherClass)) ||\n                anotherClass;\n        }\n        if (typeof anotherClass === 'string') {\n            throw new Error('Could not find \"' + anotherClass + '\" relation for ' + this.modelName);\n        }\n    }\n\n    if (!params.through) {\n        var name1 = this.modelName + anotherClass.modelName;\n        var name2 = anotherClass.modelName + this.modelName;\n        params.through = lookupModel(name1) || lookupModel(name2) ||\n            this.schema.define(name1);\n    }\n    params.through.belongsTo(this);\n    params.through.belongsTo(anotherClass);\n\n    this.hasMany(anotherClass, {as: params.as, through: params.through});\n\n    function lookupModel(modelName) {\n        var lookupClassName = modelName.toLowerCase();\n        for (var name in models) {\n            if (name.toLowerCase() === lookupClassName) {\n                return models[name];\n            }\n        }\n    }\n\n};\n","/home/travis/build/npmtest/node-npmtest-jugglingdb/node_modules/jugglingdb/lib/scope.js":"/**\n * Module exports\n */\nexports.defineScope = defineScope;\n\n/**\n * Scope mixin for ./model.js\n */\nvar Model = require('./model.js');\n\n/**\n * Define scope\n * TODO: describe behavior and usage examples\n */\nModel.scope = function (name, params) {\n    defineScope(this, this, name, params);\n};\n\nfunction defineScope(cls, targetClass, name, params, methods) {\n\n    // collect meta info about scope\n    if (!cls._scopeMeta) {\n        cls._scopeMeta = {};\n    }\n\n    // only makes sence to add scope in meta if base and target classes\n    // are same\n    if (cls === targetClass) {\n        cls._scopeMeta[name] = params;\n    } else {\n        if (!targetClass._scopeMeta) {\n            targetClass._scopeMeta = {};\n        }\n    }\n\n    Object.defineProperty(cls, name, {\n        enumerable: false,\n        configurable: true,\n        get: function () {\n            var f = function caller(condOrRefresh, cb) {\n                var actualCond = {};\n                var actualRefresh = false;\n                var saveOnCache = true;\n                if (arguments.length === 1) {\n                    cb = condOrRefresh;\n                } else if (arguments.length === 2) {\n                    if (typeof condOrRefresh === 'boolean') {\n                        actualRefresh = condOrRefresh;\n                    } else {\n                        actualCond = condOrRefresh;\n                        actualRefresh = true;\n                        saveOnCache = false;\n                    }\n                } else {\n                    throw new Error('Method can be only called with one or two arguments');\n                }\n\n                if (!this.__cachedRelations || (typeof this.__cachedRelations[name] == 'undefined') || actualRefresh) {\n                    var self = this;\n                    var params = mergeParams(actualCond, caller._scope);\n                    return targetClass.all(params, function(err, data) {\n                        if (!err && saveOnCache) {\n                            if (!self.__cachedRelations) {\n                                self.__cachedRelations = {};\n                            }\n                            self.__cachedRelations[name] = data;\n                        }\n                        cb(err, data);\n                    });\n                } else {\n                    cb(null, this.__cachedRelations[name]);\n                }\n            };\n            f._scope = typeof params === 'function' ? params.call(this) : params;\n            f.build = build;\n            f.create = create;\n            f.destroyAll = destroyAll;\n            for (var i in methods) {\n                f[i] = methods[i].bind(this);\n            }\n\n            // define sub-scopes\n            Object.keys(targetClass._scopeMeta).forEach(function (name) {\n                Object.defineProperty(f, name, {\n                    enumerable: false,\n                    get: function () {\n                        mergeParams(f._scope, targetClass._scopeMeta[name]);\n                        return f;\n                    }\n                });\n            }.bind(this));\n            return f;\n        }\n    });\n\n    // and it should have create/build methods with binded thisModelNameId param\n    function build(data) {\n        return new targetClass(mergeParams(this._scope, {where:data || {}}).where);\n    }\n\n    function create(data, cb) {\n        if (typeof data === 'function') {\n            cb = data;\n            data = {};\n        }\n        this.build(data).save(cb);\n    }\n\n    /*\n        Callback\n        - The callback will be called after all elements are destroyed\n        - For every destroy call which results in an error\n        - If fetching the Elements on which destroyAll is called results in an error\n    */\n    function destroyAll(cb) {\n        targetClass.all(this._scope, function (err, data) {\n            if (err) {\n                cb(err);\n            } else {\n                (function loopOfDestruction (data) {\n                    if(data.length > 0) {\n                        data.shift().destroy(function(err) {\n                            if(err && cb) cb(err);\n                            loopOfDestruction(data);\n                        });\n                    } else {\n                        if(cb) cb();\n                    }\n                }(data));\n            }\n        });\n    }\n\n    function mergeParams(base, update) {\n        if (update.where) {\n            base.where = merge(base.where, update.where);\n        }\n        if (update.include) {\n            base.include = update.include;\n        }\n        if (update.collect) {\n            base.collect = update.collect;\n        }\n\n        // overwrite order\n        if (update.order) {\n            base.order = update.order;\n        }\n\n        return base;\n\n    }\n}\n\n/**\n * Merge `base` and `update` params\n * @param {Object} base - base object (updating this object)\n * @param {Object} update - object with new data to update base\n * @returns {Object} `base`\n */\nfunction merge(base, update) {\n    base = base || {};\n    if (update) {\n        Object.keys(update).forEach(function (key) {\n            base[key] = update[key];\n        });\n    }\n    return base;\n}\n\n","/home/travis/build/npmtest/node-npmtest-jugglingdb/node_modules/jugglingdb/lib/include.js":"/**\n * Dependencies\n */\nvar i8n = require('inflection');\n\n/**\n * Include mixin for ./model.js\n */\nvar AbstractClass = require('./model.js');\n\n/**\n * Allows you to load relations of several objects and optimize numbers of requests.\n *\n * @param {Array} objects - array of instances\n * @param {String}, {Object} or {Array} include - which relations you want to load.\n * @param {Function} cb - Callback called when relations are loaded\n *\n * Examples:\n *\n * - User.include(users, 'posts', function() {}); will load all users posts with only one additional request.\n * - User.include(users, ['posts'], function() {}); // same\n * - User.include(users, ['posts', 'passports'], function() {}); // will load all users posts and passports with two\n *     additional requests.\n * - Passport.include(passports, {owner: 'posts'}, function() {}); // will load all passports owner (users), and all\n *     posts of each owner loaded\n * - Passport.include(passports, {owner: ['posts', 'passports']}); // ...\n * - Passport.include(passports, {owner: [{posts: 'images'}, 'passports']}); // ...\n *\n */\n\n /*jshint sub: true */\n\nAbstractClass.include = function (objects, include, cb) {\n\n    if ((include.constructor.name == 'Array' && include.length === 0) || (include.constructor.name == 'Object' && Object.keys(include).length === 0)) {\n        cb(null, objects);\n        return;\n    }\n\n    include = processIncludeJoin(include);\n\n    var keyVals = {};\n    var objsByKeys = {};\n\n    var nbCallbacks = 0;\n    var totalCallbacks = 0;\n\n    for (var i = 0; i < include.length; i++) {\n        var callback = processIncludeItem(this, objects, include[i], keyVals, objsByKeys);\n        if (callback !== null) {\n            totalCallbacks++;\n            if (callback instanceof Error) {\n                cb(callback);\n            } else {\n                includeItemCallback(callback);\n            }\n        }\n    }\n\n    if (totalCallbacks === 0) {\n        cb(null, objects);\n    }\n\n    function includeItemCallback(itemCb) {\n        nbCallbacks++;\n        itemCb(function () {\n            nbCallbacks--;\n            if (nbCallbacks === 0) {\n                cb(null, objects);\n            }\n        });\n    }\n\n    function processIncludeJoin(ij) {\n        if (typeof ij === 'string') {\n            ij = [ij];\n        }\n        if (ij.constructor.name === 'Object') {\n            var newIj = [];\n            for (var key in ij) {\n                var obj = {};\n                obj[key] = ij[key];\n                newIj.push(obj);\n            }\n            return newIj;\n        }\n        return ij;\n    }\n};\n\nfunction processIncludeItem(cls, objs, include, keyVals, objsByKeys) {\n    var relations = cls.relations;\n    var relationName, subInclude;\n\n    if (include.constructor.name === 'Object') {\n        relationName = Object.keys(include)[0];\n        subInclude = include[relationName];\n    } else {\n        relationName = include;\n        subInclude = [];\n    }\n    var relation = relations[relationName];\n\n    if (!relation) {\n        return new Error('Relation \"' + relationName + '\" is not defined for ' + cls.modelName + ' model');\n    }\n\n    var req = {\n        'where': {}\n    };\n\n    if (!keyVals[relation.keyFrom]) {\n        objsByKeys[relation.keyFrom] = {};\n        objs.filter(Boolean).forEach(function (obj) {\n            if (!objsByKeys[relation.keyFrom][obj[relation.keyFrom]]) {\n                objsByKeys[relation.keyFrom][obj[relation.keyFrom]] = [];\n            }\n            objsByKeys[relation.keyFrom][obj[relation.keyFrom]].push(obj);\n        });\n        keyVals[relation.keyFrom] = Object.keys(objsByKeys[relation.keyFrom]);\n    }\n\n    // deep clone is necessary since inq seems to change the processed array\n    var keysToBeProcessed = {};\n    var inValues = [];\n    for (var j = 0; j < keyVals[relation.keyFrom].length; j++) {\n        keysToBeProcessed[keyVals[relation.keyFrom][j]] = true;\n        if (keyVals[relation.keyFrom][j] !== 'null' && keyVals[relation.keyFrom][j] !== 'undefined') {\n            inValues.push(keyVals[relation.keyFrom][j]);\n        }\n    }\n\n    var _model, _through;\n\n    function done(err, objsIncluded, cb) {\n        var objectsFrom;\n\n        for (var i = 0; i < objsIncluded.length; i++) {\n            delete keysToBeProcessed[objsIncluded[i][relation.keyTo]];\n            objectsFrom = objsByKeys[relation.keyFrom][objsIncluded[i][relation.keyTo]];\n\n            for (var j = 0; j < objectsFrom.length; j++) {\n                if (!objectsFrom[j].__cachedRelations) {\n                    objectsFrom[j].__cachedRelations = {};\n                }\n                if (relation.multiple) {\n                    if (!objectsFrom[j].__cachedRelations[relationName]) {\n                        objectsFrom[j].__cachedRelations[relationName] = [];\n                    }\n\n                    if (_through) {\n                        objectsFrom[j].__cachedRelations[relationName].push(objsIncluded[i].__cachedRelations[_through]);\n                    } else {\n                        objectsFrom[j].__cachedRelations[relationName].push(objsIncluded[i]);\n                    }\n                } else {\n                    if (_through) {\n                        objectsFrom[j].__cachedRelations[relationName] = objsIncluded[i].__cachedRelations[_through];\n                    } else {\n                        objectsFrom[j].__cachedRelations[relationName] = objsIncluded[i];\n                    }\n                }\n            }\n        }\n\n        // No relation have been found for these keys\n        for (var key in keysToBeProcessed) {\n            objectsFrom = objsByKeys[relation.keyFrom][key];\n            for (var k = 0; k < objectsFrom.length; k++) {\n                if (!objectsFrom[k].__cachedRelations) {\n                    objectsFrom[k].__cachedRelations = {};\n                }\n                objectsFrom[k].__cachedRelations[relationName] = relation.multiple ? [] : null;\n            }\n        }\n\n        cb(err, objsIncluded);\n    }\n\n    if (keyVals[relation.keyFrom].length > 0) {\n\n        if (relation.modelThrough) {\n            req['where'][relation.keyTo] = { inq: inValues };\n\n            _model = cls.schema.models[relation.modelThrough.modelName];\n            _through = i8n.camelize(relation.modelTo.modelName, true);\n\n        } else {\n            req['where'][relation.keyTo] = { inq: inValues };\n            req['include'] = subInclude;\n        }\n\n        return function (cb) {\n\n            if (_through) {\n\n                relation.modelThrough.all(req, function (err, objsIncluded) {\n\n                    _model.include(objsIncluded, _through, function (err, throughIncludes) {\n\n                        done(err, throughIncludes, cb);\n                    });\n                });\n\n            } else {\n\n                relation.modelTo.all(req, function (err, objsIncluded) {\n\n                    done(err, objsIncluded, cb);\n                });\n            }\n        };\n    }\n\n    return null;\n}\n","/home/travis/build/npmtest/node-npmtest-jugglingdb/node_modules/jugglingdb/lib/sql.js":"module.exports = BaseSQL;\n\n/**\n * Base SQL class\n */\nfunction BaseSQL() {\n}\n\nBaseSQL.prototype.query = function () {\n    throw new Error('query method should be declared in adapter');\n};\n\nBaseSQL.prototype.command = function (sql, callback) {\n    return this.query(sql, callback);\n};\n\nBaseSQL.prototype.queryOne = function (sql, callback) {\n    return this.query(sql, function (err, data) {\n        if (err) return callback(err);\n        callback(err, data[0]);\n    });\n};\n\nBaseSQL.prototype.table = function (model) {\n    return this._models[model].model.tableName;\n};\n\nBaseSQL.prototype.escapeName = function (name) {\n    throw new Error('escapeName method should be declared in adapter');\n};\n\nBaseSQL.prototype.tableEscaped = function (model) {\n    return this.escapeName(this.table(model));\n};\n\nBaseSQL.prototype.define = function (descr) {\n    if (!descr.settings) descr.settings = {};\n    this._models[descr.model.modelName] = descr;\n};\n\nBaseSQL.prototype.defineProperty = function (model, prop, params) {\n    this._models[model].properties[prop] = params;\n};\n\nBaseSQL.prototype.escapeId = function(id) {\n    if (this.schema.settings.slave) {\n        if (null === id) {\n            return 'NULL';\n        }\n        return '\"' + ('undefined' === typeof id ? '' : id.toString().replace(/[\"\\n]/g, '')) + '\"';\n    } else {\n        var idNumber = Number(id);\n        if (isNaN(idNumber)) {\n            throw new Error('id is not a number');\n        }\n        return idNumber;\n    }\n};\n\nBaseSQL.prototype.save = function (model, data, callback) {\n    var sql = 'UPDATE ' + this.tableEscaped(model) + ' SET ' + this.toFields(model, data) + ' WHERE ' + this.escapeName('id') + ' = ' + this.escapeId(data.id);\n\n    this.query(sql, function (err) {\n        callback(err);\n    });\n};\n\n\nBaseSQL.prototype.exists = function (model, id, callback) {\n    var sql = 'SELECT 1 FROM ' +\n        this.tableEscaped(model) + ' WHERE ' + this.escapeName('id') + ' = ' + this.escapeId(id) + ' LIMIT 1';\n\n    this.query(sql, function (err, data) {\n        if (err) return callback(err);\n        callback(null, data.length === 1);\n    });\n};\n\nBaseSQL.prototype.find = function find(model, id, callback) {\n    var idNumber = this.escapeId(id);\n    var sql = 'SELECT * FROM ' +\n        this.tableEscaped(model) + ' WHERE ' + this.escapeName('id') + ' = ' + idNumber + ' LIMIT 1';\n\n    this.query(sql, function (err, data) {\n        if (data && data.length === 1) {\n            data[0].id = id;\n        } else {\n            data = [null];\n        }\n        callback(err, this.fromDatabase(model, data[0]));\n    }.bind(this));\n};\n\nBaseSQL.prototype.destroy = function destroy(model, id, callback) {\n    var sql = 'DELETE FROM ' +\n        this.tableEscaped(model) + ' WHERE ' + this.escapeName('id') + ' = ' + this.escapeId(id);\n\n    this.command(sql, function (err) {\n        callback(err);\n    });\n};\n\nBaseSQL.prototype.destroyAll = function destroyAll(model, callback) {\n    this.command('DELETE FROM ' + this.tableEscaped(model), function (err) {\n        if (err) {\n            return callback(err, []);\n        }\n        callback(err);\n    }.bind(this));\n};\n\nBaseSQL.prototype.count = function count(model, callback, where) {\n    var self = this;\n    var props = this._models[model].properties;\n\n    this.queryOne('SELECT count(*) as cnt FROM ' +\n        this.tableEscaped(model) + ' ' + buildWhere(where), function (err, res) {\n        if (err) return callback(err);\n        callback(err, res && res.cnt);\n    });\n\n    function buildWhere(conds) {\n        var cs = [];\n        Object.keys(conds || {}).forEach(function (key) {\n            var keyEscaped = self.escapeName(key);\n            if (conds[key] === null) {\n                cs.push(keyEscaped + ' IS NULL');\n            } else {\n                cs.push(keyEscaped + ' = ' + self.toDatabase(props[key], conds[key]));\n            }\n        });\n        return cs.length ? ' WHERE ' + cs.join(' AND ') : '';\n    }\n};\n\nBaseSQL.prototype.updateAttributes = function updateAttrs(model, id, data, cb) {\n    data.id = id;\n    this.save(model, data, cb);\n};\n\nBaseSQL.prototype.disconnect = function disconnect() {\n    this.client.end();\n};\n\nBaseSQL.prototype.automigrate = function (cb) {\n    var self = this;\n    var wait = 0;\n    Object.keys(this._models).forEach(function (model) {\n        wait += 1;\n        self.dropTable(model, function () {\n            // console.log('drop', model);\n            self.createTable(model, function (err) {\n                // console.log('create', model);\n                if (err) console.log(err);\n                done();\n            });\n        });\n    });\n    if (wait === 0) cb();\n\n    function done() {\n        if (--wait === 0 && cb) {\n            cb();\n        }\n    }\n};\n\nBaseSQL.prototype.dropTable = function (model, cb) {\n    this.command('DROP TABLE IF EXISTS ' + this.tableEscaped(model), cb);\n};\n\nBaseSQL.prototype.createTable = function (model, cb) {\n    this.command('CREATE TABLE ' + this.tableEscaped(model) +\n        ' (\\n  ' + this.propertiesSQL(model) + '\\n)', cb);\n};\n\n","/home/travis/build/npmtest/node-npmtest-jugglingdb/node_modules/jugglingdb/test/common_test.js":"\nvar Schema = require('../index').Schema;\nvar Text = Schema.Text;\n\nvar nbSchemaRequests = 0;\n\nvar batch;\nvar schemaName;\n\nfunction it(name, cases) {\n    batch[schemaName][name] = cases;\n}\n\nfunction skip(name) {\n    delete batch[schemaName][name];\n}\n\nmodule.exports = function testSchema(exportCasesHere, schema) {\n\n    batch = exportCasesHere;\n    schemaName = schema.name;\n    if (schema.name.match(/^\\/.*\\/test\\/\\.\\.$/)) {\n        schemaName = schemaName.split('/').slice(-3).shift();\n    }\n    var start;\n\n    batch['should connect to database'] = function (test) {\n        start = Date.now();\n        if (schema.connected) return test.done();\n        schema.on('connected', test.done);\n    };\n\n    schema.log = function (a) {\n        console.log(a);\n        nbSchemaRequests++;\n    };\n\n    batch[schemaName] = {};\n\n    testOrm(schema);\n\n    batch['all tests done'] = function (test) {\n        test.done();\n        process.nextTick(allTestsDone);\n    };\n\n    function allTestsDone() {\n        schema.disconnect();\n        console.log('Test done in %dms\\n', Date.now() - start);\n    }\n\n};\n\nObject.defineProperty(module.exports, 'it', {\n    writable: true,\n    enumerable: false,\n    configurable: true,\n    value: it\n});\n\nObject.defineProperty(module.exports, 'skip', {\n    writable: true,\n    enumerable: false,\n    configurable: true,\n    value: skip\n});\n\nfunction clearAndCreate(model, data, callback) {\n    var createdItems = [];\n    model.destroyAll(function () {\n        nextItem(null, null);\n    });\n\n    var itemIndex = 0;\n    function nextItem(err, lastItem) {\n        if (lastItem !== null) {\n            createdItems.push(lastItem);\n        }\n        if (itemIndex >= data.length) {\n            callback(createdItems);\n            return;\n        }\n        model.create(data[itemIndex], nextItem);\n        itemIndex++;\n    }\n}\n\nfunction testOrm(schema) {\n    var requestsAreCounted = schema.name !== 'mongodb';\n\n    var Post, User, Passport, Log, Dog;\n\n    it('should define class', function (test) {\n\n        User = schema.define('User', {\n            name:      { type: String, index: true },\n            email:     { type: String, index: true },\n            bio:          Text,\n            approved:     Boolean,\n            joinedAt:     Date,\n            age:          Number,\n            passwd:    { type: String, index: true }\n        });\n\n        Dog = schema.define('Dog', {\n            name        : { type: String, limit: 64, allowNull: false }\n        });\n\n        Log = schema.define('Log', {\n            ownerId     : { type: Number, allowNull: true },\n            name         : { type: String, limit: 64, allowNull: false }\n        });\n\n        Log.belongsTo(Dog,  {as: 'owner',  foreignKey: 'ownerId'});\n\n        schema.extendModel('User', {\n            settings:  { type: Schema.JSON },\n            extra:      Object\n        });\n\n        var newuser = new User({settings: {hey: 'you'}});\n        test.ok(newuser.settings);\n\n        Post = schema.define('Post', {\n            title:     { type: String, length: 255, index: true },\n            subject:   { type: String },\n            content:   { type: Text },\n            date:      { type: Date,    default: function () { return new Date }, index: true },\n            published: { type: Boolean, default: false, index: true },\n            likes:     [],\n            related:   [RelatedPost]\n        }, {table: 'posts'});\n\n        function RelatedPost() { }\n        RelatedPost.prototype.someMethod = function () {\n            return this.parent;\n        };\n\n        Post.validateAsync('title', function (err, done) {\n            process.nextTick(done);\n        });\n\n        User.hasMany(Post,   {as: 'posts',  foreignKey: 'userId'});\n        // creates instance methods:\n        // user.posts(conds)\n        // user.posts.build(data) // like new Post({userId: user.id});\n        // user.posts.create(data) // build and save\n        // user.posts.find\n\n        // User.hasOne('latestPost', {model: Post, foreignKey: 'postId'});\n\n        // User.hasOne(Post,    {as: 'latestPost', foreignKey: 'latestPostId'});\n        // creates instance methods:\n        // user.latestPost()\n        // user.latestPost.build(data)\n        // user.latestPost.create(data)\n\n        Post.belongsTo(User, {as: 'author', foreignKey: 'userId'});\n        // creates instance methods:\n        // post.author(callback) -- getter when called with function\n        // post.author() -- sync getter when called without params\n        // post.author(user) -- setter when called with object\n\n        Passport = schema.define('Passport', {\n            number: String\n        });\n\n        Passport.belongsTo(User, {as: 'owner', foreignKey: 'ownerId'});\n        User.hasMany(Passport,   {as: 'passports', foreignKey: 'ownerId'});\n\n        var user = new User;\n\n        test.ok(User instanceof Function);\n\n        // class methods\n        test.ok(User.find instanceof Function);\n        test.ok(User.create instanceof Function);\n\n        // instance methods\n        test.ok(user.save instanceof Function);\n\n        schema.automigrate(function (err) {\n            if (err) {\n                console.log('Error while migrating');\n                console.log(err);\n            } else {\n                test.done();\n            }\n        });\n\n    });\n\n    it('should initialize object properly', function (test) {\n        var hw = 'Hello word',\n            now = Date.now(),\n            post = new Post({title: hw}),\n            anotherPost = Post({title: 'Resig style constructor'});\n\n        test.equal(post.title, hw);\n        test.ok(!post.propertyChanged('title'), 'property changed: title');\n        post.title = 'Goodbye, Lenin';\n        test.equal(post.title_was, hw);\n        test.ok(post.propertyChanged('title'));\n        test.strictEqual(post.published, false);\n        test.ok(post.date >= now);\n        test.ok(post.isNewRecord());\n        test.ok(anotherPost instanceof Post);\n        test.ok(anotherPost.title, 'Resig style constructor');\n        test.done();\n    });\n\n    it('should save object', function (test) {\n        var title = 'Initial title', title2 = 'Hello world',\n            date = new Date;\n\n        Post.create({\n            title: title,\n            date: date\n        }, function (err, obj) {\n            test.ok(obj.id, 'Object id should present');\n            test.equals(obj.title, title);\n            // test.equals(obj.date, date);\n            obj.title = title2;\n            test.ok(obj.propertyChanged('title'), 'Title changed');\n            obj.save(function (err, obj) {\n                test.equal(obj.title, title2);\n                test.ok(!obj.propertyChanged('title'));\n\n                var p = new Post({title: 1});\n                p.title = 2;\n                p.save(function (err, obj) {\n                    test.ok(!p.propertyChanged('title'));\n                    p.title = 3;\n                    test.ok(p.propertyChanged('title'));\n                    test.equal(p.title_was, 2);\n                    p.save(function () {\n                        test.equal(p.title_was, 3);\n                        test.ok(!p.propertyChanged('title'));\n                        test.done();\n                    });\n                });\n            });\n        });\n    });\n\n    it('should create object with initial data', function (test) {\n        var title = 'Initial title',\n            date = new Date;\n\n        Post.create({\n            title: title,\n            date: date\n        }, function (err, obj) {\n            test.ok(obj.id);\n            test.equals(obj.title, title);\n            test.equals(obj.date, date);\n            Post.find(obj.id, function () {\n                test.equal(obj.title, title);\n                test.equal(obj.date.toString(), date.toString());\n                test.done();\n            });\n        });\n    });\n\n    it('should save only schema-defined field in database', function (test) {\n        Post.create({title: '1602', nonSchemaField: 'some value'}, function (err, post) {\n            test.ok(!post.nonSchemaField);\n            post.a = 1;\n            post.save(function () {\n                test.ok(post.a);\n                post.reload(function (err, psto) {\n                    test.ok(!psto.a);\n                    test.done();\n                });\n            });\n        });\n    });\n\n    /*\n    it('should not create new instances for the same object', function (test) {\n        var title = 'Initial title';\n        Post.create({ title: title }, function (err, post) {\n            test.ok(post.id, 'Object should have id');\n            test.equals(post.title, title);\n            Post.find(post.id, function (err, foundPost) {\n                if (err) throw err;\n                test.equal(post.title, title);\n                test.strictEqual(post, foundPost);\n                test.done();\n            });\n        });\n    });\n    */\n\n    it('should not re-instantiate object on saving', function (test) {\n        var title = 'Initial title';\n        var post = new Post({title: title});\n        post.save(function (err, savedPost) {\n            test.strictEqual(post, savedPost);\n            test.done();\n        });\n    });\n\n    it('should destroy object', function (test) {\n        Post.create(function (err, post) {\n            Post.exists(post.id, function (err, exists) {\n                test.ok(exists, 'Object exists');\n                post.destroy(function () {\n                    Post.exists(post.id, function (err, exists) {\n                        if (err) console.log(err);\n                        test.ok(!exists, 'Hey! ORM told me that object exists, but it looks like it doesn\\'t. Something went wrong...');\n                        Post.find(post.id, function (err, obj) {\n                            test.equal(obj, null, 'Param obj should be null');\n                            test.done();\n                        });\n                    });\n                });\n            });\n        });\n    });\n\n    it('should handle virtual attributes', function (test) {\n        var salt = 's0m3s3cr3t5a1t';\n\n        User.setter.passwd = function (password) {\n            this._passwd = calcHash(password, salt);\n        };\n\n        function calcHash(pass, salt) {\n            var crypto = require('crypto');\n            var hash = crypto.createHash('sha256');\n            hash.update(pass);\n            hash.update(salt);\n            return hash.digest('base64');\n        }\n\n        var u = new User;\n        u.passwd = 's3cr3t';\n        test.equal(u.passwd, calcHash('s3cr3t', salt));\n        test.done();\n    });\n\n    // it('should serialize JSON type', function (test) {\n    //     User.create({settings: {hello: 'world'}}, function (err, user) {\n    //         test.ok(user.id);\n    //         test.equal(user.settings.hello, 'world');\n    //         User.find(user.id, function (err, u) {\n    //             console.log(u.settings);\n    //             test.equal(u.settings.hello, 'world');\n    //             test.done();\n    //         });\n    //     });\n    // });\n\n    it('should update single attribute', function (test) {\n        Post.create({title: 'title', content: 'content', published: true}, function (err, post) {\n            post.content = 'New content';\n            post.updateAttribute('title', 'New title', function () {\n                test.equal(post.title, 'New title');\n                test.ok(!post.propertyChanged('title'));\n                test.equal(post.content, 'New content', 'dirty state saved');\n                test.ok(post.propertyChanged('content'));\n                post.reload(function (err, post) {\n                    test.equal(post.title, 'New title');\n                    test.ok(!post.propertyChanged('title'), 'title not changed');\n                    test.equal(post.content, 'content', 'real value turned back');\n                    test.ok(!post.propertyChanged('content'), 'content unchanged');\n                    test.done();\n                });\n            });\n        });\n    });\n\n    var countOfposts, countOfpostsFiltered;\n    it('should fetch collection', function (test) {\n        Post.all(function (err, posts) {\n            countOfposts = posts.length;\n            test.ok(countOfposts > 0);\n            test.ok(posts[0] instanceof Post);\n            countOfpostsFiltered = posts.filter(function (p) {\n                return p.title === 'title';\n            }).length;\n            test.done();\n        });\n    });\n\n    it('should find records filtered with multiple attributes', function (test) {\n        var d = new Date;\n        Post.create({title: 'title', content: 'content', published: true, date: d}, function (err, post) {\n            Post.all({where: {title: 'title', date: d, published: true}}, function (err, res) {\n                test.equals(res.length, 1, 'Filtering Posts returns one post');\n                test.done();\n            });\n        });\n    });\n\n    if (\n        !schema.name.match(/redis/) &&\n            schema.name !== 'memory' &&\n            schema.name !== 'neo4j' &&\n            schema.name !== 'cradle'\n        )\n    it('relations key is working', function (test) {\n        test.ok(User.relations, 'Relations key should be defined');\n        test.ok(User.relations.posts, 'posts relation should exist on User');\n        test.equal(User.relations.posts.type, 'hasMany', 'Type of hasMany relation is hasMany');\n        test.equal(User.relations.posts.multiple, true, 'hasMany relations are multiple');\n        test.equal(User.relations.posts.keyFrom, 'id', 'keyFrom is primary key of model table');\n        test.equal(User.relations.posts.keyTo, 'userId', 'keyTo is foreign key of related model table');\n\n        test.ok(Post.relations, 'Relations key should be defined');\n        test.ok(Post.relations.author, 'author relation should exist on Post');\n        test.equal(Post.relations.author.type, 'belongsTo', 'Type of belongsTo relation is belongsTo');\n        test.equal(Post.relations.author.multiple, false, 'belongsTo relations are not multiple');\n        test.equal(Post.relations.author.keyFrom, 'userId', 'keyFrom is foreign key of model table');\n        test.equal(Post.relations.author.keyTo, 'id', 'keyTo is primary key of related model table');\n        test.done();\n    });\n\n\n    it('should handle hasMany relationship', function (test) {\n        User.create(function (err, u) {\n            if (err) return console.log(err);\n            test.ok(u.posts, 'Method defined: posts');\n            test.ok(u.posts.build, 'Method defined: posts.build');\n            test.ok(u.posts.create, 'Method defined: posts.create');\n            u.posts.create(function (err, post) {\n                if (err) return console.log(err);\n                u.posts(function (err, posts) {\n                    test.equal(posts.pop().id.toString(), post.id.toString());\n                    test.done();\n                });\n            });\n        });\n    });\n\n    it('should navigate variations of belongsTo regardless of column name', function(test){\n\n        Dog.create({name: 'theDog'}, function(err, obj){\n            test.ok(obj instanceof Dog);\n            Log.create({name: 'theLog', ownerId: obj.id}, function(err, obj){\n                test.ok(obj instanceof Log);\n                obj.owner(function(err, obj){\n                    test.ok(!err, 'Should not have an error.'); // Before cba174b this would be 'Error: Permission denied'\n                    if(err){\n                        console.log('Found: ' + err);\n                    }\n                    test.ok(obj, 'Should not find null or undefined.'); // Before cba174b this could be null or undefined.\n                    test.ok(obj instanceof Dog, 'Should find a Dog.');\n                    if(obj){ // Since test won't stop on fail, have to check before accessing obj.name.\n                        test.ok(obj.name, 'Should have a name.');\n                    }\n                    if(obj && obj.name){\n                        test.equal(obj.name, 'theDog', 'The owner of theLog is theDog.');\n                    }\n                    test.done();\n                });\n            });\n        });\n    });\n\n    it('hasMany should support additional conditions', function (test) {\n\n        User.create(function (e, u) {\n            u.posts.create({}, function (e, p) {\n                u.posts({where: {id: p.id}}, function (e, posts) {\n                    test.equal(posts.length, 1, 'There should be only 1 post.');\n                    test.done();\n                });\n            });\n        });\n\n    });\n\n    it('hasMany should be cached', function (test) {\n        //User.create(function (e, u) {\n        //    u.posts.create({}, function (e, p) {\n        // find all posts for a user.\n        // Finding one post with an existing author associated\n        Post.all(function (err, posts) {\n            // We try to get the first post with a userId != NULL\n            for (var i = 0; i < posts.length; i++) {\n                var post = posts[i];\n                if (post.userId) {\n                    // We could get the user with belongs to relationship but it is better if there is no interactions.\n                    User.find(post.userId, function(err, user) {\n                        User.create(function(err, voidUser) {\n                            Post.create({userId: user.id}, function() {\n\n                                // There can't be any concurrency because we are counting requests\n                                // We are first testing cases when user has posts\n                                user.posts(function(err, data) {\n                                    var nbInitialRequests = nbSchemaRequests;\n                                    user.posts(function(err, data2) {\n                                        test.equal(data.length, 2, 'There should be 2 posts.');\n                                        test.equal(data.length, data2.length, 'Posts should be the same, since we are loading on the same object.');\n                                        requestsAreCounted && test.equal(nbInitialRequests, nbSchemaRequests, 'There should not be any request because value is cached.');\n\n                                        if (schema.name === 'mongodb') { // for the moment mongodb doesn\\'t support additional conditions on hasMany relations (see above)\n                                            test.done();\n                                        } else {\n                                            user.posts({where: {id: data[0].id}}, function(err, data) {\n                                                test.equal(data.length, 1, 'There should be only one post.');\n                                                requestsAreCounted && test.equal(nbInitialRequests + 1, nbSchemaRequests, 'There should be one additional request since we added conditions.');\n\n                                                user.posts(function(err, data) {\n                                                    test.equal(data.length, 2, 'Previous get shouldn\\'t have changed cached value though, since there was additional conditions.');\n                                                    requestsAreCounted && test.equal(nbInitialRequests + 1, nbSchemaRequests, 'There should not be any request because value is cached.');\n\n                                                    // We are now testing cases when user doesn't have any post\n                                                    voidUser.posts(function(err, data) {\n                                                        var nbInitialRequests = nbSchemaRequests;\n                                                        voidUser.posts(function(err, data2) {\n                                                            test.equal(data.length, 0, 'There shouldn\\'t be any posts (1/2).');\n                                                            test.equal(data2.length, 0, 'There shouldn\\'t be any posts (2/2).');\n                                                            requestsAreCounted && test.equal(nbInitialRequests, nbSchemaRequests, 'There should not be any request because value is cached.');\n\n                                                            voidUser.posts(true, function(err, data3) {\n                                                                test.equal(data3.length, 0, 'There shouldn\\'t be any posts.');\n                                                                requestsAreCounted && test.equal(nbInitialRequests + 1, nbSchemaRequests, 'There should be one additional request since we forced refresh.');\n\n                                                                test.done();\n                                                            });\n                                                        });\n                                                    });\n\n                                                });\n                                            });\n                                        }\n\n                                    });\n                                });\n\n                            });\n                        });\n                    });\n                    break;\n                }\n            }\n        });\n\n    });\n\n    // it('should handle hasOne relationship', function (test) {\n    //     User.create(function (err, u) {\n    //         if (err) return console.log(err);\n    //     });\n    // });\n\n    it('should support scopes', function (test) {\n        var wait = 2;\n\n        test.ok(Post.scope, 'Scope supported');\n        Post.scope('published', {where: {published: true}});\n        test.ok(typeof Post.published === 'function');\n        test.ok(Post.published._scope.where.published === true);\n        var post = Post.published.build();\n        test.ok(post.published, 'Can build');\n        test.ok(post.isNewRecord());\n        Post.published.create(function (err, psto) {\n            if (err) return console.log(err);\n            test.ok(psto.published);\n            test.ok(!psto.isNewRecord());\n            done();\n        });\n\n        User.create(function (err, u) {\n            if (err) return console.log(err);\n            test.ok(typeof u.posts.published == 'function');\n            test.ok(u.posts.published._scope.where.published);\n            console.log(u.posts.published._scope);\n            test.equal(u.posts.published._scope.where.userId, u.id);\n            done();\n        });\n\n        function done() {\n            if (--wait === 0) test.done();\n        };\n    });\n\n    it('should return type of property', function (test) {\n        test.equal(Post.whatTypeName('title'), 'String');\n        test.equal(Post.whatTypeName('content'), 'Text');\n        var p = new Post;\n        test.equal(p.whatTypeName('title'), 'String');\n        test.equal(p.whatTypeName('content'), 'Text');\n        test.done();\n    });\n\n    it('should handle ORDER clause', function (test) {\n        var titles = [ { title: 'Title A', subject: \"B\" },\n                       { title: 'Title Z', subject: \"A\" },\n                       { title: 'Title M', subject: \"C\" },\n                       { title: 'Title A', subject: \"A\" },\n                       { title: 'Title B', subject: \"A\" },\n                       { title: 'Title C', subject: \"D\" }];\n        var isRedis = Post.schema.name === 'redis';\n        var dates = isRedis ? [ 5, 9, 0, 17, 10, 9 ] : [\n            new Date(1000 * 5 ),\n            new Date(1000 * 9),\n            new Date(1000 * 0),\n            new Date(1000 * 17),\n            new Date(1000 * 10),\n            new Date(1000 * 9)\n        ];\n        titles.forEach(function (t, i) {\n            Post.create({title: t.title, subject: t.subject, date: dates[i]}, done);\n        });\n\n        var i = 0, tests = 0;\n        function done(err, obj) {\n            if (++i === titles.length) {\n                doFilterAndSortTest();\n                doFilterAndSortReverseTest();\n                doStringTest();\n                doNumberTest();\n\n                if (schema.name == 'mongoose') {\n                    doMultipleSortTest();\n                    doMultipleReverseSortTest();\n                }\n            }\n        }\n\n        function compare(a, b) {\n            if (a.title < b.title) return -1;\n            if (a.title > b.title) return 1;\n            return 0;\n        }\n\n        // Post.schema.log = console.log;\n\n        function doStringTest() {\n            tests += 1;\n            Post.all({order: 'title'}, function (err, posts) {\n                if (err) console.log(err);\n                test.equal(posts.length, 6);\n                titles.sort(compare).forEach(function (t, i) {\n                    if (posts[i]) test.equal(posts[i].title, t.title);\n                });\n                finished();\n            });\n        }\n\n        function doNumberTest() {\n            tests += 1;\n            Post.all({order: 'date'}, function (err, posts) {\n                if (err) console.log(err);\n                test.equal(posts.length, 6);\n                dates.sort(numerically).forEach(function (d, i) {\n                    if (posts[i])\n                    test.equal(posts[i].date.toString(), d.toString(), 'doNumberTest');\n                });\n                finished();\n            });\n        }\n\n        function doFilterAndSortTest() {\n            tests += 1;\n            Post.all({where: {date: new Date(1000 * 9)}, order: 'title', limit: 3}, function (err, posts) {\n                if (err) console.log(err);\n                console.log(posts.length);\n                test.equal(posts.length, 2, 'Exactly 2 posts returned by query');\n                [ 'Title C', 'Title Z' ].forEach(function (t, i) {\n                    if (posts[i]) {\n                        test.equal(posts[i].title, t, 'doFilterAndSortTest');\n                    }\n                });\n                finished();\n            });\n        }\n\n        function doFilterAndSortReverseTest() {\n            tests += 1;\n            Post.all({where: {date: new Date(1000 * 9)}, order: 'title DESC', limit: 3}, function (err, posts) {\n                if (err) console.log(err);\n                test.equal(posts.length, 2, 'Exactly 2 posts returned by query');\n                [ 'Title Z', 'Title C' ].forEach(function (t, i) {\n                    if (posts[i]) {\n                        test.equal(posts[i].title, t, 'doFilterAndSortReverseTest');\n                    }\n                });\n                finished();\n            });\n        }\n\n        function doMultipleSortTest() {\n            tests += 1;\n            Post.all({order: \"title ASC, subject ASC\"}, function(err, posts) {\n                if (err) console.log(err);\n                test.equal(posts.length, 6);\n                test.equal(posts[0].title, \"Title A\");\n                test.equal(posts[0].subject, \"A\");\n                test.equal(posts[1].title, \"Title A\");\n                test.equal(posts[1].subject, \"B\");\n                test.equal(posts[5].title, \"Title Z\");\n                finished();\n            });\n        }\n\n        function doMultipleReverseSortTest() {\n            tests += 1;\n            Post.all({order: \"title ASC, subject DESC\"}, function(err, posts) {\n                if (err) console.log(err);\n                test.equal(posts.length, 6);\n                test.equal(posts[0].title, \"Title A\");\n                test.equal(posts[0].subject, \"B\");\n                test.equal(posts[1].title,\"Title A\");\n                test.equal(posts[1].subject, \"A\");\n                test.equal(posts[5].title, \"Title Z\");\n                finished();\n            });\n        }\n\n        var fin = 0;\n        function finished() {\n            if (++fin === tests) {\n                test.done();\n            }\n        }\n\n        // TODO: do mixed test, do real dates tests, ensure that dates stored in UNIX timestamp format\n\n        function numerically(a, b) {\n            return a - b;\n        }\n\n    });\n\n    // if (\n    //     !schema.name.match(/redis/) &&\n    //     schema.name !== 'memory' &&\n    //     schema.name !== 'neo4j' &&\n    //     schema.name !== 'cradle' &&\n    //     schema.name !== 'nano'\n    // )\n    // it('should allow advanced queying: lt, gt, lte, gte, between', function (test) {\n    //     Post.destroyAll(function () {\n    //         Post.create({date: new Date('Wed, 01 Feb 2012 13:56:12 GMT')}, done);\n    //         Post.create({date: new Date('Thu, 02 Feb 2012 13:56:12 GMT')}, done);\n    //         Post.create({date: new Date('Fri, 03 Feb 2012 13:56:12 GMT')}, done);\n    //         Post.create({date: new Date('Sat, 04 Feb 2012 13:56:12 GMT')}, done);\n    //         Post.create({date: new Date('Sun, 05 Feb 2012 13:56:12 GMT')}, done);\n    //         Post.create({date: new Date('Mon, 06 Feb 2012 13:56:12 GMT')}, done);\n    //         Post.create({date: new Date('Tue, 07 Feb 2012 13:56:12 GMT')}, done);\n    //         Post.create({date: new Date('Wed, 08 Feb 2012 13:56:12 GMT')}, done);\n    //         Post.create({date: new Date('Thu, 09 Feb 2012 13:56:12 GMT')}, done);\n    //     });\n\n    //     var posts = 9;\n    //     function done() {\n    //         if (--posts === 0) makeTest();\n    //     }\n\n    //     function makeTest() {\n    //         // gt\n    //         Post.all({where: {date: {gt: new Date('Tue, 07 Feb 2012 13:56:12 GMT')}}}, function (err, posts) {\n    //             test.equal(posts.length, 2, 'gt');\n    //             ok();\n    //         });\n\n    //         // gte\n    //         Post.all({where: {date: {gte: new Date('Tue, 07 Feb 2012 13:56:12 GMT')}}}, function (err, posts) {\n    //             test.equal(posts.length, 3, 'gte');\n    //             ok();\n    //         });\n\n    //         // lte\n    //         Post.all({where: {date: {lte: new Date('Tue, 07 Feb 2012 13:56:12 GMT')}}}, function (err, posts) {\n    //             test.equal(posts.length, 7, 'lte');\n    //             ok();\n    //         });\n\n    //         // lt\n    //         Post.all({where: {date: {lt: new Date('Tue, 07 Feb 2012 13:56:12 GMT')}}}, function (err, posts) {\n    //             test.equal(posts.length, 6, 'lt');\n    //             ok();\n    //         });\n\n    //         // between\n    //         Post.all({where: {date: {between: [new Date('Tue, 05 Feb 2012 13:56:12 GMT'), new Date('Tue, 09 Feb 2012 13:56:12 GMT')]}}}, function (err, posts) {\n    //             test.equal(posts.length, 5, 'between');\n    //             ok();\n    //         });\n    //     }\n\n    //     var tests = 5;\n    //     function ok() {\n    //         if (--tests === 0) test.done();\n    //     }\n    // });\n\n\n    // if (\n    //     schema.name === 'mysql' ||\n    //     schema.name === 'postgres'\n    // )\n    // it('should allow IN or NOT IN', function (test) {\n    //     User.destroyAll(function () {\n    //         User.create({name: 'User A', age: 21}, done);\n    //         User.create({name: 'User B', age: 22}, done);\n    //         User.create({name: 'User C', age: 23}, done);\n    //         User.create({name: 'User D', age: 24}, done);\n    //         User.create({name: 'User E', age: 25}, done);\n    //     });\n\n    //     var users = 5;\n    //     function done() {\n    //         if (--users === 0) makeTest();\n    //     }\n\n    //     function makeTest() {\n    //         // IN with empty array should return nothing\n    //         User.all({where: {name: {inq: []}}}, function (err, users) {\n    //             test.equal(users.length, 0, 'IN with empty array returns nothing');\n    //             ok();\n    //         });\n\n    //         // NOT IN with empty array should return everything\n    //         User.all({where: {name: {nin: []}}}, function (err, users) {\n    //             test.equal(users.length, 5, 'NOT IN with empty array returns everything');\n    //             ok();\n    //         });\n\n    //         // IN [User A] returns user with name = User A\n    //         User.all({where: {name: {inq: ['User A']}}}, function (err, users) {\n    //             test.equal(users.length, 1, 'IN searching one existing value returns 1 user');\n    //             test.equal(users[0].name, 'User A', 'IN [User A] returns user with name = User A');\n    //             ok();\n    //         });\n\n    //         // NOT IN [User A] returns users with name != User A\n    //         User.all({where: {name: {nin: ['User A']}}}, function (err, users) {\n    //             test.equal(users.length, 4, 'IN [User A] returns users with name != User A');\n    //             ok();\n    //         });\n\n    //         // IN [User A, User B] returns users with name = User A OR name = User B\n    //         User.all({where: {name: {inq: ['User A', 'User B']}}}, function (err, users) {\n    //             test.equal(users.length, 2, 'IN searching two existing values returns 2 users');\n    //             ok();\n    //         });\n\n    //         // NOT IN [User A, User B] returns users with name != User A AND name != User B\n    //         User.all({where: {name: {nin: ['User A', 'User B']}}}, function (err, users) {\n    //             test.equal(users.length, 3, 'NOT IN searching two existing values returns users with name != User A AND name != User B');\n    //             ok();\n    //         });\n\n    //         // IN works with numbers too\n    //         User.all({where: {age: {inq: [21, 22]}}}, function (err, users) {\n    //             test.equal(users.length, 2, 'IN works with numbers too');\n    //             ok();\n    //         });\n\n    //         // NOT IN works with numbers too\n    //         User.all({where: {age: {nin: [21, 22]}}}, function (err, users) {\n    //             test.equal(users.length, 3, 'NOT IN works with numbers too');\n    //             ok();\n    //         });\n    //     }\n\n    //     var tests = 8;\n    //     function ok() {\n    //         if (--tests === 0) test.done();\n    //     }\n    // });\n\n    it('should handle order clause with direction', function (test) {\n        var wait = 0;\n        var emails = [\n            'john@hcompany.com',\n            'tom@hcompany.com',\n            'admin@hcompany.com',\n            'tin@hcompany.com',\n            'mike@hcompany.com',\n            'susan@hcompany.com',\n            'test@hcompany.com'\n        ];\n        User.destroyAll(function () {\n            emails.forEach(function (email) {\n                wait += 1;\n                User.create({email: email, name: 'Nick'}, done);\n            });\n        });\n        var tests = 2;\n        function done() {\n            process.nextTick(function () {\n                if (--wait === 0) {\n                    doSortTest();\n                    doReverseSortTest();\n                }\n            });\n        }\n\n        function doSortTest() {\n            User.all({order: 'email ASC', where: {name: 'Nick'}}, function (err, users) {\n                var _emails = emails.sort();\n                users.forEach(function (user, i) {\n                    test.equal(_emails[i], user.email, 'ASC sorting');\n                });\n                testDone();\n            });\n        }\n\n        function doReverseSortTest() {\n            User.all({order: 'email DESC', where: {name: 'Nick'}}, function (err, users) {\n                var _emails = emails.sort().reverse();\n                users.forEach(function (user, i) {\n                    test.equal(_emails[i], user.email, 'DESC sorting');\n                });\n                testDone();\n            });\n        }\n\n        function testDone() {\n            if (--tests === 0) test.done();\n        }\n    });\n\n    it('should return id in find result even after updateAttributes', function (test) {\n        Post.create(function (err, post) {\n            var id = post.id;\n            test.ok(post.published === false);\n            post.updateAttributes({title: 'hey', published: true}, function () {\n                Post.find(id, function (err, post) {\n                    test.ok(!!post.published, 'Update boolean field');\n                    test.ok(post.id);\n                    test.done();\n                });\n            });\n        });\n    });\n\n    it('should handle belongsTo correctly', function (test) {\n        var passport = new Passport({ownerId: 16});\n        // sync getter\n        test.equal(passport.owner(), 16);\n        // sync setter\n        passport.owner(18);\n        test.equal(passport.owner(), 18);\n        test.done();\n    });\n\n    it('should query one record', function (test) {\n        test.expect(4);\n        Post.findOne(function (err, post) {\n            test.ok(post && post.id);\n            Post.findOne({ where: { title: 'hey' } }, function (err, post) {\n                if (err) {\n                    console.log(err);\n                    return test.done();\n                }\n                test.equal(post && post.constructor.modelName, 'Post');\n                test.equal(post && post.title, 'hey');\n                Post.findOne({ where: { title: 'not exists' } }, function (err, post) {\n                    test.ok(post === null);\n                    test.done();\n                });\n            });\n        });\n    });\n\n    // if (\n    //     !schema.name.match(/redis/) &&\n    //         schema.name !== 'memory' &&\n    //         schema.name !== 'neo4j' &&\n    //         schema.name !== 'cradle' &&\n    //         schema.name !== 'nano'\n    //     )\n    // it('belongsTo should be cached', function (test) {\n    //     User.findOne(function(err, user) {\n\n    //         var passport = new Passport({ownerId: user.id});\n    //         var passport2 = new Passport({ownerId: null});\n\n    //         // There can't be any concurrency because we are counting requests\n    //         // We are first testing cases when passport has an owner\n    //         passport.owner(function(err, data) {\n    //             var nbInitialRequests = nbSchemaRequests;\n    //             passport.owner(function(err, data2) {\n    //                 test.equal(data.id, data2.id, 'The value should remain the same');\n    //                 requestsAreCounted && test.equal(nbInitialRequests, nbSchemaRequests, 'There should not be any request because value is cached.');\n\n    //                 // We are now testing cases when passport has not an owner\n    //                 passport2.owner(function(err, data) {\n    //                     var nbInitialRequests2 = nbSchemaRequests;\n    //                     passport2.owner(function(err, data2) {\n    //                         test.equal(data, null, 'The value should be null since there is no owner');\n    //                         test.equal(data, data2, 'The value should remain the same (null)');\n    //                         requestsAreCounted && test.equal(nbInitialRequests2, nbSchemaRequests, 'There should not be any request because value is cached.');\n\n    //                         passport2.owner(user.id);\n    //                         passport2.owner(function(err, data3) {\n    //                             test.equal(data3.id, user.id, 'Owner should now be the user.');\n    //                             requestsAreCounted && test.equal(nbInitialRequests2 + 1, nbSchemaRequests, 'If we changed owner id, there should be one more request.');\n\n    //                             passport2.owner(true, function(err, data4) {\n    //                                 test.equal(data3.id, data3.id, 'The value should remain the same');\n    //                                 requestsAreCounted && test.equal(nbInitialRequests2 + 2, nbSchemaRequests, 'If we forced refreshing, there should be one more request.');\n    //                                 test.done();\n    //                             });\n    //                         });\n    //                     });\n    //                 });\n\n    //             });\n    //         });\n    //     });\n\n    // });\n\n    if (schema.name !== 'mongoose' && schema.name !== 'neo4j')\n    it('should update or create record', function (test) {\n        var newData = {\n            id: 1,\n            title: 'New title (really new)',\n            content: 'Some example content (updated)'\n        };\n        Post.updateOrCreate(newData, function (err, updatedPost) {\n            if (err) throw err;\n            test.ok(updatedPost);\n            if (!updatedPost) throw Error('No post!');\n\n            if (schema.name !== 'mongodb') {\n                test.equal(newData.id, updatedPost.toObject().id);\n            }\n            test.equal(newData.title, updatedPost.toObject().title);\n            test.equal(newData.content, updatedPost.toObject().content);\n\n            Post.find(updatedPost.id, function (err, post) {\n                if (err) throw err;\n                if (!post) throw Error('No post!');\n                if (schema.name !== 'mongodb') {\n                    test.equal(newData.id, post.toObject().id);\n                }\n                test.equal(newData.title, post.toObject().title);\n                test.equal(newData.content, post.toObject().content);\n                Post.updateOrCreate({id: 100001, title: 'hey'}, function (err, post) {\n                    if (schema.name !== 'mongodb') test.equal(post.id, 100001);\n                    test.equal(post.title, 'hey');\n                    Post.find(post.id, function (err, post) {\n                        if (!post) throw Error('No post!');\n                        test.done();\n                    });\n                });\n            });\n        });\n    });\n\n    it('should work with custom setters and getters', function (test) {\n        User.schema.defineForeignKey('User', 'passwd');\n        User.setter.passwd = function (pass) {\n            this._passwd = pass + 'salt';\n        };\n        var u = new User({passwd: 'qwerty'});\n        test.equal(u.passwd, 'qwertysalt');\n        u.save(function (err, user) {\n            User.find(user.id, function (err, user) {\n                test.ok(user !== u);\n                test.equal(user.passwd, 'qwertysalt');\n                User.all({where: {passwd: 'qwertysalt'}}, function (err, users) {\n                    test.ok(users[0] !== user);\n                    test.equal(users[0].passwd, 'qwertysalt');\n                    User.create({passwd: 'asalat'}, function (err, usr) {\n                        test.equal(usr.passwd, 'asalatsalt');\n                        User.upsert({passwd: 'heyman'}, function (err, us) {\n                            test.equal(us.passwd, 'heymansalt');\n                            User.find(us.id, function (err, user) {\n                                test.equal(user.passwd, 'heymansalt');\n                                test.done();\n                            });\n                        });\n                    });\n                });\n            });\n        });\n    });\n\n    it('should work with typed and untyped nested collections', function (test) {\n        var post = new Post;\n        var like = post.likes.push({foo: 'bar'});\n        test.equal(like.constructor.name, 'ListItem');\n        var related = post.related.push({hello: 'world'});\n        test.ok(related.someMethod);\n        post.save(function (err, p) {\n            test.equal(p.likes.nextid, 2);\n            p.likes.push({second: 2});\n            p.likes.push({third: 3});\n            p.save(function (err) {\n                Post.find(p.id, function (err, pp) {\n                    test.equal(pp.likes.length, 3);\n                    test.ok(pp.likes[3].third);\n                    test.ok(pp.likes[2].second);\n                    test.ok(pp.likes[1].foo);\n                    pp.likes.remove(2);\n                    test.equal(pp.likes.length, 2);\n                    test.ok(!pp.likes[2]);\n                    pp.likes.remove(pp.likes[1]);\n                    test.equal(pp.likes.length, 1);\n                    test.ok(!pp.likes[1]);\n                    test.ok(pp.likes[3]);\n                    pp.save(function () {\n                        Post.find(p.id, function (err, pp) {\n                            test.equal(pp.likes.length, 1);\n                            test.ok(!pp.likes[1]);\n                            test.ok(pp.likes[3]);\n                            test.done();\n                        });\n                    });\n                });\n            });\n        });\n    });\n\n    it('should find or create', function (test) {\n        var email = 'some email ' + Math.random();\n        User.findOrCreate({where: {email: email}}, function (err, u) {\n            test.ok(u);\n            test.ok(!u.age);\n            User.findOrCreate({where: {email: email}}, {age: 21}, function (err, u2) {\n                test.equals(u.id.toString(), u2.id.toString(), 'Same user ids');\n                test.ok(!u2.age);\n                test.done();\n            });\n        });\n    });\n\n}\n","/home/travis/build/npmtest/node-npmtest-jugglingdb/node_modules/jugglingdb/lib/jutil.js":"exports.inherits = function (newClass, baseClass) {\n    Object.keys(baseClass).forEach(function (classMethod) {\n        newClass[classMethod] = baseClass[classMethod];\n    });\n    Object.keys(baseClass.prototype).forEach(function (instanceMethod) {\n        newClass.prototype[instanceMethod] = baseClass.prototype[instanceMethod];\n    });\n};\n\n","/home/travis/build/npmtest/node-npmtest-jugglingdb/node_modules/jugglingdb/lib/railway.js":"var fs = require('fs');\nvar path = require('path');\nvar Schema = require('./schema').Schema;\n\nvar existsSync = fs.existsSync || path.existsSync;\n\nif (global.railway) {\n    railway.orm._schemas = [];\n}\n\nmodule.exports = function init(root) {\n    var railway, app, models;\n\n    if (typeof root !== 'object' || (root.constructor.name !== 'Compound' && root.constructor.name !== 'CompoundServer')) {\n        railway = global.railway;\n        app = global.app;\n        models = app.models;\n    } else {\n        railway = root;\n        app = railway.app;\n        root = railway.root;\n        models = railway.models;\n    }\n\n    railway.orm._schemas = [];\n\n    var confFile = (root || app.root) + '/config/database';\n    var appConf = app.get('database');\n    var config = railway.orm.config = appConf || {};\n    var env = app.set('env');\n    var schema;\n\n    if (!railway.parent) {\n        if (!appConf) {\n            try {\n                var cf = require(confFile);\n                if (cf instanceof Array) {\n                    cf = cf[0];\n                }\n                if (typeof cf === 'function') {\n                    config = cf(railway);\n                } else {\n                    config = cf[env];\n                }\n            } catch (e) {\n                console.log('Could not load config/database.{js|json|yml}');\n                throw e;\n            }\n        }\n\n        if (!config) {\n            console.log('No environment ' + env + ' found in config/database.{js|json|yml}');\n            throw new Error('No environment ' + env + ' found in config/database.{js|json|yml}');\n        }\n\n        // when driver name started with point - look for driver in app root (relative path)\n        if (config.driver && config.driver.match(/^\\./)) {\n            config.driver = path.join(app.root, config.driver);\n        }\n\n        schema = new Schema(config && config.driver || 'memory', config);\n        schema.log = log;\n        if (!schema.adapter) throw new Error('Adapter is not defined');\n\n    } else {\n        schema = railway.parent.orm._schemas[0];\n    }\n\n    if (schema.waitForConnect) {\n        schema.on('connected', function() {\n            loadSchema(schema, railway, app, models);\n        });\n    } else {\n        loadSchema(schema, railway, app, models);\n    }\n\n// check validations and display warning\n\nvar displayWarning = false;\nObject.keys(models).forEach(function (model) {\n    var Model = models[model];\n    if (Model._validations) {\n        displayWarning = true;\n    }\n});\n\nfunction loadSchema(schema, railway, app, models) {\n    railway.orm._schemas.push(schema);\n\n    var context = prepareContext(models, railway, app, schema);\n\n    // run schema first\n    var schemaFile = (root || app.root) + '/db/schema.';\n    if (existsSync(schemaFile + 'js')) {\n        schemaFile += 'js';\n    } else if (existsSync(schemaFile + 'coffee')) {\n        schemaFile += 'coffee';\n    } else {\n        schemaFile = false;\n    }\n\n    if (schemaFile) {\n        var code = fs.readFileSync(schemaFile).toString();\n        if (schemaFile.match(/\\.coffee$/)) {\n            code = require('coffee-script').compile(code);\n        }\n        /*jshint evil: true */\n        var fn = new Function('context', 'require', 'with(context){(function(){' + code + '})()}');\n        fn(context, require);\n    }\n\n    // autoupdate if set app.enable('autoupdate')  or freeze schemas by default\n    railway.orm._schemas.forEach(function (schema) {\n        if(app.enabled('autoupdate')){\n            schema.autoupdate();\n        } else {\n            schema.freeze();\n        }\n    });\n}\n\nfunction log(str, startTime) {\n    var $ = railway.utils.stylize.$;\n    var m = Date.now() - startTime;\n    railway.utils.debug(str + $(' [' + (m < 10 ? m : $(m).red) + ' ms]').bold);\n    app.emit('app-event', {\n        type: 'query',\n        param: str,\n        time: m\n    });\n}\n\nfunction prepareContext(models, railway, app, defSchema, done) {\n    var ctx = {app: app},\n        _models = {},\n        settings = {},\n        cname,\n        schema,\n        connected = 0,\n        wait = 0,\n        nonJugglingSchema = false;\n\n    done = done || function () {};\n\n    /**\n     * Multiple schemas support\n     * example:\n     * schema('redis', {url:'...'}, function () {\n     *     describe models using redis connection\n     *     ...\n     * });\n     * schema(function () {\n     *     describe models stored in memory\n     *     ...\n     * });\n     */\n    ctx.schema = function () {\n        var name = argument('string');\n        var opts = argument('object') || {};\n        var def = argument('function') || function () {};\n        schema = new Schema(name || opts.driver || 'memory', opts);\n        railway.orm._schemas.push(schema);\n        wait += 1;\n        ctx.gotSchema = true;\n        schema.on('log', log);\n        schema.on('connected', function () {\n            if (wait === ++connected) done();\n        });\n        def();\n        schema = false;\n    };\n\n    /**\n     * Use custom schema driver\n     */\n    ctx.customSchema = function () {\n        var def = argument('function') || function () {};\n        nonJugglingSchema = true;\n        def();\n        Object.keys(ctx.exports).forEach(function (m) {\n            ctx.define(m, ctx.exports[m]);\n        });\n        nonJugglingSchema = false;\n    };\n    ctx.exports = {};\n    ctx.module = { exports: ctx.exports };\n\n    /**\n     * Define a class in current schema\n     */\n    ctx.describe = ctx.define = function (className, callback) {\n        var m;\n        cname = className;\n        _models[cname] = {};\n        settings[cname] = {};\n        if (nonJugglingSchema) {\n            m = callback;\n        } else {\n            if ('function' === typeof callback) {\n                callback();\n            }\n            m = (schema || defSchema).define(className, _models[cname], settings[cname]);\n        }\n        if (global.railway) {\n            global[cname] = m;\n        }\n        models[cname] = ctx[cname] = m;\n        return m;\n    };\n\n    /**\n     * Define a property in current class\n     */\n    ctx.property = function (name, type, params) {\n        if (!params) params = {};\n        if (typeof type !== 'function' && typeof type === 'object' && !(type instanceof Array)) {\n            params = type;\n            type = String;\n        }\n        params.type = type || String;\n        _models[cname][name] = params;\n    };\n\n    /**\n     * Set custom table name for current class\n     * @param name - name of table\n     */\n    ctx.setTableName = function (name) {\n        if (cname) settings[cname].table = name;\n    };\n\n    /**\n     * Set configuration param\n     *\n     * @param name - name of param.\n     * @param value - value.\n     */\n    ctx.set = function (name, value) {\n        if (cname) settings[cname][name] = value;\n    };\n\n    ctx.pathTo = railway.map && railway.map.pathTo || {};\n\n    /**\n     * If the Schema has additional types, add them to the context\n     * e.g. MySQL has an additional Point type\n     */\n    if (Schema.types && Object.keys(Schema.types).length) {\n        for (var typeName in Schema.types) {\n            ctx[typeName] = Schema.types[typeName];\n        }\n    }\n\n    return ctx;\n\n    function argument(type) {\n        var r;\n        [].forEach.call(arguments.callee.caller.arguments, function (a) {\n            if (!r && typeof a === type) r = a;\n        });\n        return r;\n    }\n}\n\n};\n","/home/travis/build/npmtest/node-npmtest-jugglingdb/node_modules/jugglingdb/lib/utils.js":"exports.safeRequire = safeRequire;\n\nfunction safeRequire(module) {\n    try {\n        return require(module);\n    } catch (e) {\n        console.log('Run \"npm install jugglingdb ' + module + '\" command to use jugglingdb using ' + module + ' database engine');\n        process.exit(1);\n    }\n}\n\n","/home/travis/build/npmtest/node-npmtest-jugglingdb/node_modules/jugglingdb/lib/adapters/cradle.js":"var safeRequire = require('../utils').safeRequire;\n\n/**\n * Module dependencies\n */\nvar cradle = safeRequire('cradle');\n\n/**\n * Private functions for internal use\n */\nfunction CradleAdapter(client) {\n    this._models = {};\n    this.client = client;\n}\n\nfunction createdbif(client, callback) {\n    client.exists(function (err, exists) {\n        if(err) callback(err);\n        if (!exists) { client.create(function() { callback(); }); }\n        else { callback(); }\n    });\n}\n\nfunction naturalize(data, table) {\n    data.nature = table;\n    //TODO: maybe this is not a really good idea\n    if(data.date) data.date = data.date.toString();\n    return data;\n}\nfunction idealize(data) {\n    data.id = data._id;\n    return data;\n}\nfunction stringify(data) {\n    return data ? data.toString() : data;\n}\n\nfunction errorHandler(callback, func) {\n    return function(err, res) {\n        if (err) {\n            console.log('cradle', err);\n            callback(err);\n        } else {\n            if(func) {\n                func(res, function(res) {\n                    callback(null, res);\n                });\n            } else {\n                callback(null, res);\n            }\n        }\n    };\n}\n\nfunction synchronize(functions, args, callback) {\n    if(functions.length === 0) callback();\n    if(functions.length > 0 && args.length === functions.length) {\n        functions[0](args[0][0], args[0][1], function(err, res) {\n            if(err) callback(err);\n            functions.splice(0, 1);\n            args.splice(0, 1);\n            synchronize(functions, args, callback);\n        });\n    }\n}\n\nfunction applyFilter(filter) {\n    if (typeof filter.where === 'function') {\n        return filter.where;\n    }\n    var keys = Object.keys(filter.where);\n    return function (obj) {\n        var pass = true;\n        keys.forEach(function (key) {\n            if (!test(filter.where[key], obj[key])) {\n                pass = false;\n            }\n        });\n        return pass;\n    };\n\n    function test(example, value) {\n        if (typeof value === 'string' && example && example.constructor.name === 'RegExp') {\n            return value.match(example);\n        }\n        // not strict equality\n        return example == value;\n    }\n}\n\nfunction numerically(a, b) {\n   return a[this[0]] - b[this[0]];\n}\n\nfunction literally(a, b) {\n   return a[this[0]] > b[this[0]];\n}\n\nfunction filtering(res, model, filter, instance) {\n   if (model) {\n      if (filter === null) {\n          filter = {};\n      }\n      if (filter.where === null) {\n          filter.where = {};\n      }\n      // use table() function on fake instance\n      filter.where.nature = CradleAdapter.prototype.table.call({_models: instance}, model);\n   }\n   // do we need some filtration?\n   if (filter.where) {\n      res = res ? res.filter(applyFilter(filter)) : res;\n   }\n\n   // do we need some sorting?\n   if (filter.order) {\n      var props = instance[model].properties;\n      var allNumeric = true;\n      var orders = filter.order;\n      var reverse = false;\n      if (typeof filter.order === \"string\") {\n         orders = [filter.order];\n      }\n\n      orders.forEach(function (key, i) {\n         var m = key.match(/\\s+(A|DE)SC$/i);\n         if (m) {\n            key = key.replace(/\\s+(A|DE)SC/i, '');\n            if (m[1] === 'DE') reverse = true;\n         }\n         orders[i] = key;\n         if (props[key].type.name !== 'Number') {\n            allNumeric = false;\n         }\n      });\n      if (allNumeric) {\n         res = res.sort(numerically.bind(orders));\n      } else {\n         res = res.sort(literally.bind(orders));\n      }\n      if (reverse) res = res.reverse();\n   }\n   return res;\n}\n\n/**\n * Connection/Disconnection\n */\nexports.initialize = function(schema, callback) {\n    if (!cradle) return;\n\n    // when using cradle if we dont wait for the schema to be connected, the models fails to load correctly.\n    schema.waitForConnect = true;\n    if (!schema.settings.url) {\n        var host = schema.settings.host || 'localhost';\n        var port = schema.settings.port || '5984';\n        var options = schema.settings.options || {\n           cache: true,\n           raw: false\n        };\n        if (schema.settings.username) {\n            options.auth = {};\n            options.auth.username = schema.settings.username;\n            if (schema.settings.password) {\n                options.auth.password = schema.settings.password;\n            }\n        }\n        var database = schema.settings.database || 'jugglingdb';\n\n        schema.settings.host = host;\n        schema.settings.port = port;\n        schema.settings.database = database;\n        schema.settings.options = options;\n    }\n    schema.client = new(cradle.Connection)(schema.settings.host, schema.settings.port,schema.settings.options).database(schema.settings.database);\n\n    createdbif(\n       schema.client,\n       errorHandler(callback, function() {\n          schema.adapter = new CradleAdapter(schema.client);\n          process.nextTick(callback);\n       }));\n};\n\nCradleAdapter.prototype.disconnect = function() {\n};\n\n/**\n * Write methods\n */\nCradleAdapter.prototype.define = function(descr) {\n    this._models[descr.model.modelName] = descr;\n};\n\nCradleAdapter.prototype.create = function(model, data, callback) {\n    this.client.save(\n       stringify(data.id),\n       naturalize(data, this.table(model)),\n       errorHandler(callback, function(res, cb) {\n          cb(res.id);\n       })\n    );\n};\n\nCradleAdapter.prototype.save = function(model, data, callback) {\n   this.client.save(\n       stringify(data.id),\n       naturalize(data, this.table(model)),\n       errorHandler(callback)\n   );\n};\n\nCradleAdapter.prototype.updateAttributes = function(model, id, data, callback) {\n    this.client.merge(\n       stringify(id),\n       data,\n       errorHandler(callback, function(doc, cb) {\n          cb(idealize(doc));\n       })\n    );\n};\n\nCradleAdapter.prototype.updateOrCreate = function(model, data, callback) {\n   this.client.get(\n      stringify(data.id),\n      function (err, doc) {\n         if (err) {\n            this.create(model, data, callback);\n         } else {\n            this.updateAttributes(model, data.id, data, callback);\n         }\n      }.bind(this)\n   );\n};\n\n/**\n * Read methods\n */\nCradleAdapter.prototype.exists = function(model, id, callback) {\n    this.client.get(\n       stringify(id), \n       errorHandler(callback, function(doc, cb) {\n          cb(!!doc);   \n       })\n    );\n};\n\nCradleAdapter.prototype.find = function(model, id, callback) {\n    this.client.get(\n       stringify(id),\n       errorHandler(callback, function(doc, cb) {\n          cb(idealize(doc));\n       })\n    );\n};\n\nCradleAdapter.prototype.count = function(model, callback, where) {\n    this.models(\n       model,\n       {where: where},\n       callback,\n       function(docs, cb) {\n          cb(docs.length);\n       }\n    );\n};\n\nCradleAdapter.prototype.models = function(model, filter, callback, func) {\n    var limit = 200;\n    var skip  = 0;\n    if (filter !== null) {\n        limit = filter.limit || limit;\n        skip  = filter.skip ||skip;\n    }\n\n    var self = this;\n    var table = this.table(model);\n\n    self.client.save('_design/'+table, {\n        views : {\n            all : {\n                map : 'function(doc) { if (doc.nature == \"'+table+'\") { emit(doc._id, doc); } }'\n            }\n        }\n    }, function() {\n        self.client.view(table+'/all', {include_docs:true, limit:limit, skip:skip}, errorHandler(callback, function(res, cb) {\n            var docs = res.map(function(doc) {\n                return idealize(doc);\n            });\n            var filtered = filtering(docs, model, filter, this._models);\n\n            if ('function' === typeof func) {\n                func(filtered, cb);\n            } else {\n                cb(filtered);\n            }\n        }.bind(self)));\n    });\n};\n\nCradleAdapter.prototype.all = function(model, filter, callback) {\n   this.models(\n       model,\n       filter,\n       callback\n   );\n};\n\n/**\n * Detroy methods\n */\nCradleAdapter.prototype.destroy = function(model, id, callback) {\n    this.client.remove(\n       stringify(id),\n       function (err, doc) {\n         callback(err);\n       }\n    );\n};\n\nCradleAdapter.prototype.destroyAll = function(model, callback) {\n   this.models(\n       model,\n       null,\n       callback,\n       function(docs, cb) {\n          var docIds = docs.map(function(doc) {\n             return doc.id;                     \n          });\n          this.client.get(docIds, function(err, res) {\n             if(err) cb(err);\n\n             var funcs = res.map(function(doc) {\n                return this.client.remove.bind(this.client);\n             }.bind(this));\n\n             var args = res.map(function(doc) {\n                return [doc._id, doc._rev];\n             });\n\n             synchronize(funcs, args, cb);\n          }.bind(this));\n       }.bind(this)\n   );\n};\n\nCradleAdapter.prototype.table = function(model) {\n    return this._models[model].model.tableName;\n};\n","/home/travis/build/npmtest/node-npmtest-jugglingdb/node_modules/jugglingdb/lib/adapters/http.js":"exports.initialize = function initializeSchema(schema, callback) {\n    schema.adapter = new WebService();\n    process.nextTick(callback);\n};\n\nfunction WebService() {\n    this._models = {};\n    this.cache = {};\n    this.ids = {};\n}\n\nWebService.prototype.installPostProcessor = function installPostProcessor(descr) {\n    var dates = [];\n    Object.keys(descr.properties).forEach(function(column) {\n        if (descr.properties[column].type.name === 'Date') {\n            dates.push(column);\n        }\n    });\n\n    var postProcessor = function(model) {\n        var max = dates.length;\n        for (var i = 0; i < max; i++) {\n            var column = dates[i];\n            if (model[column]) {\n                model[column] = new Date(model[column]);\n            }\n        }\n    };\n\n    descr.postProcessor = postProcessor;\n};\n\nWebService.prototype.preProcess = function preProcess(data) {\n    var result = {};\n    Object.keys(data).forEach(function(key) {\n        if (data[key] !== null) {\n            result[key] = data[key];\n        }\n    });\n    return result;\n};\n\nWebService.prototype.postProcess = function postProcess(model, data) {\n    var postProcessor = this._models[model].postProcessor;\n    if (postProcessor && data) {\n        postProcessor(data);\n    }\n};\n\nWebService.prototype.postProcessMultiple = function postProcessMultiple(model, data) {\n    var postProcessor = this._models[model].postProcessor;\n    if (postProcessor) {\n        var max = data.length;\n        for (var i = 0; i < max; i++) {\n            if (data[i]) {\n                postProcessor(data[i]);\n            }\n        }\n    }\n};\n\nWebService.prototype.define = function defineModel(descr) {\n    var m = descr.model.modelName;\n    this.installPostProcessor(descr);\n    this._models[m] = descr;\n};\n\nWebService.prototype.getResourceUrl = function getResourceUrl(model) {\n    var url = this._models[model].settings.restPath;\n    if (!url) throw new Error('Resource url (restPath) for ' + model + ' is not defined');\n    return url;\n};\n\nWebService.prototype.getBlankReq = function () {\n    if (!this.csrfToken) {\n        this.csrfToken = $('meta[name=csrf-token]').attr('content');\n        this.csrfParam = $('meta[name=csrf-param]').attr('content');\n    }\n    var req = {};\n    req[this.csrfParam] = this.csrfToken;\n    return req;\n};\n\nWebService.prototype.create = function create(model, data, callback) {\n    var req = this.getBlankReq();\n    req[model] = this.preProcess(data);\n    $.post(this.getResourceUrl(model) + '.json', req, function (res) {\n        if (res.code === 200) {\n            callback(null, res.data.id);\n        } else {\n            callback(res.error);\n        }\n    }, 'json');\n    // this.cache[model][id] = data;\n};\n\nWebService.prototype.updateOrCreate = function (model, data, callback) {\n    var mem = this;\n    this.exists(model, data.id, function (err, exists) {\n        if (exists) {\n            mem.save(model, data, callback);\n        } else {\n            mem.create(model, data, function (err, id) {\n                data.id = id;\n                callback(err, data);\n            });\n        }\n    });\n};\n\nWebService.prototype.save = function save(model, data, callback) {\n    var _this = this;\n    var req = this.getBlankReq();\n    req._method = 'PUT';\n    req[model] = this.preProcess(data);\n    $.post(this.getResourceUrl(model) + '/' + data.id + '.json', req, function (res) {\n        if (res.code === 200) {\n            _this.postProcess(model, res.data);\n            callback(null, res.data);\n        } else {\n            callback(res.error);\n        }\n    }, 'json');\n};\n\nWebService.prototype.exists = function exists(model, id, callback) {\n    $.getJSON(this.getResourceUrl(model) + '/' + id + '.json', function (res) {\n        if (res.code === 200) {\n            callback(null, true);\n        } else if (res.code === 404) {\n            callback(null, false);\n        } else {\n            callback(res.error);\n        }\n    });\n};\n\nWebService.prototype.find = function find(model, id, callback) {\n    var _this = this;\n    $.getJSON(this.getResourceUrl(model) + '/' + id + '.json', function (res) {\n        if (res.code === 200) {\n            _this.postProcess(model, res.data);\n            callback(null, res.data);\n        } else {\n            callback(res.error);\n        }\n    });\n};\n\nWebService.prototype.destroy = function destroy(model, id, callback) {\n    var _this = this;\n    var req = this.getBlankReq();\n    req._method = 'DELETE';\n    $.post(this.getResourceUrl(model) + '/' + id + '.json', req, function (res) {\n        if (res.code === 200) {\n            //delete _this.cache[model][id];\n            callback(null, res.data);\n        } else {\n            callback(res.error);\n        }\n    }, 'json');\n};\n\nWebService.prototype.all = function all(model, filter, callback) {\n    var _this = this;\n    $.getJSON(this.getResourceUrl(model) + '.json?query=' + encodeURIComponent(JSON.stringify(filter)), function (res) {\n        if (res.code === 200) {\n            _this.postProcessMultiple(model, res.data);\n            callback(null, res.data);\n        } else {\n            callback(res.error);\n        }\n    });\n};\n\nWebService.prototype.destroyAll = function destroyAll(model, callback) {\n    throw new Error('Not supported');\n};\n\nWebService.prototype.count = function count(model, callback, where) {\n    throw new Error('Not supported');\n};\n\nWebService.prototype.updateAttributes = function(model, id, data, callback) {\n    data.id = id;\n    this.save(model, data, callback);\n};\n\n","/home/travis/build/npmtest/node-npmtest-jugglingdb/node_modules/jugglingdb/lib/adapters/memory.js":"exports.initialize = function initializeSchema(schema, callback) {\n    schema.adapter = new Memory();\n    schema.adapter.connect(callback);\n};\n\nfunction Memory(m) {\n    if (m) {\n        this.isTransaction = true;\n        this.cache = m.cache;\n        this.ids = m.ids;\n        this._models = m._models;\n    } else {\n        this.isTransaction = false;\n        this.cache = {};\n        this.ids = {};\n        this._models = {};\n    }\n}\n\nMemory.prototype.connect = function(callback) {\n    if (this.isTransaction) {\n        this.onTransactionExec = callback;\n    } else {\n        process.nextTick(callback);\n    }\n};\n\nMemory.prototype.define = function defineModel(descr) {\n    var m = descr.model.modelName;\n    this._models[m] = descr;\n    this.cache[this.table(m)] = {};\n    this.ids[m] = 1;\n};\n\nMemory.prototype.create = function create(model, data, callback) {\n    var id = data.id || this.ids[model]++;\n    data.id = id;\n    this.cache[this.table(model)][id] = JSON.stringify(data);\n    process.nextTick(function() {\n        callback(null, id);\n    });\n};\n\nMemory.prototype.updateOrCreate = function (model, data, callback) {\n    var mem = this;\n    this.exists(model, data.id, function (err, exists) {\n        if (exists) {\n            mem.save(model, data, callback);\n        } else {\n            mem.create(model, data, function (err, id) {\n                data.id = id;\n                callback(err, data);\n            });\n        }\n    });\n};\n\nMemory.prototype.save = function save(model, data, callback) {\n    this.cache[this.table(model)][data.id] = JSON.stringify(data);\n    process.nextTick(function () {\n        callback(null, data);\n    });\n};\n\nMemory.prototype.exists = function exists(model, id, callback) {\n    var table = this.table(model);\n    process.nextTick(function () {\n        callback(null, this.cache[table].hasOwnProperty(id));\n    }.bind(this));\n};\n\nMemory.prototype.find = function find(model, id, callback) {\n    var table = this.table(model);\n    process.nextTick(function () {\n        callback(null, id in this.cache[table] && this.fromDb(model, this.cache[table][id]));\n    }.bind(this));\n};\n\nMemory.prototype.destroy = function destroy(model, id, callback) {\n    delete this.cache[this.table(model)][id];\n    process.nextTick(callback);\n};\n\nMemory.prototype.fromDb = function(model, data) {\n    if (!data) return null;\n    data = JSON.parse(data);\n    var props = this._models[model].properties;\n    Object.keys(data).forEach(function (key) {\n        var val = data[key];\n        if (typeof val === 'undefined' || val === null) {\n            return;\n        }\n        if (props[key]) {\n            switch(props[key].type.name) {\n                case 'Date':\n                val = new Date(val.toString().replace(/GMT.*$/, 'GMT'));\n                break;\n                case 'Boolean':\n                val = Boolean(val);\n                break;\n            }\n        }\n        data[key] = val;\n    });\n    return data;\n};\n\nMemory.prototype.all = function all(model, filter, callback) {\n    var self = this;\n    var table = this.table(model);\n    var nodes = Object.keys(this.cache[table]).map(function (key) {\n        return this.fromDb(model, this.cache[table][key]);\n    }.bind(this));\n\n    if (filter) {\n\n        // do we need some sorting?\n        if (filter.order) {\n            var props = this._models[model].properties;\n            var orders = filter.order;\n            if (typeof filter.order === \"string\") {\n                orders = [filter.order];\n            }\n            orders.forEach(function (key, i) {\n                var reverse = 1;\n                var m = key.match(/\\s+(A|DE)SC$/i);\n                if (m) {\n                    key = key.replace(/\\s+(A|DE)SC/i, '');\n                    if (m[1].toLowerCase() === 'de') reverse = -1;\n                }\n                orders[i] = {\"key\": key, \"reverse\": reverse};\n            });\n            nodes = nodes.sort(sorting.bind(orders));\n        }\n\n        // do we need some filtration?\n        if (filter.where) {\n            nodes = nodes ? nodes.filter(applyFilter(filter)) : nodes;\n        }\n\n        // limit/skip\n        filter.skip = filter.skip || 0;\n        filter.limit = filter.limit || nodes.length;\n        nodes = nodes.slice(filter.skip, filter.skip + filter.limit);\n\n    }\n\n    process.nextTick(function () {\n        if (filter && filter.include) {\n            self._models[model].model.include(nodes, filter.include, callback);\n        } else {\n            callback(null, nodes);\n        }\n    });\n\n    function sorting(a, b) {\n        for (var i=0, l=this.length; i<l; i++) {\n            if (a[this[i].key] > b[this[i].key]) {\n                return 1*this[i].reverse;\n            } else  if (a[this[i].key] < b[this[i].key]) {\n                return -1*this[i].reverse;\n            }\n        }\n        return 0;\n    }\n};\n\nfunction applyFilter(filter) {\n    if (typeof filter.where === 'function') {\n        return filter.where;\n    }\n    var keys = Object.keys(filter.where);\n    return function (obj) {\n        var pass = true;\n        keys.forEach(function (key) {\n            if (!test(filter.where[key], obj[key])) {\n                pass = false;\n            }\n        });\n        return pass;\n    };\n\n    function test(example, value) {\n        if (typeof value === 'string' && example && example.constructor.name === 'RegExp') {\n            return value.match(example);\n        }\n        if (typeof example === 'undefined') return undefined;\n        if (typeof value === 'undefined') return undefined;\n        if (typeof example === 'object') {\n            if (example === null) {\n                return value === null;\n            }\n            if (example.inq) {\n                if (!value) return false;\n                for (var i = 0; i < example.inq.length; i += 1) {\n                    if (example.inq[i] == value) return true;\n                }\n                return false;\n            }\n        }\n        // not strict equality\n        return (example !== null ? example.toString() : example) == (value !== null ? value.toString() : value);\n    }\n}\n\nMemory.prototype.destroyAll = function destroyAll(model, callback) {\n    var table = this.table(model);\n    Object.keys(this.cache[table]).forEach(function (id) {\n        delete this.cache[table][id];\n    }.bind(this));\n    this.cache[table] = {};\n    process.nextTick(callback);\n};\n\nMemory.prototype.count = function count(model, callback, where) {\n    var cache = this.cache[this.table(model)];\n    var data = Object.keys(cache);\n    if (where) {\n        data = data.filter(function (id) {\n            var ok = true;\n            Object.keys(where).forEach(function (key) {\n                if (JSON.parse(cache[id])[key] != where[key]) {\n                    ok = false;\n                }\n            });\n            return ok;\n        });\n    }\n    process.nextTick(function () {\n        callback(null, data.length);\n    });\n};\n\nMemory.prototype.updateAttributes = function updateAttributes(model, id, data, cb) {\n    data.id = id;\n    var base = JSON.parse(this.cache[this.table(model)][id]);\n    this.save(model, merge(base, data), cb);\n};\n\nMemory.prototype.transaction = function () {\n    return new Memory(this);\n};\n\nMemory.prototype.exec = function(callback) {\n    this.onTransactionExec();\n    setTimeout(callback, 50);\n};\n\nMemory.prototype.table = function (model) {\n    return this._models[model].model.tableName;\n};\n\nfunction merge(base, update) {\n    if (!base) return update;\n    Object.keys(update).forEach(function (key) {\n        base[key] = update[key];\n    });\n    return base;\n}\n\n","/home/travis/build/npmtest/node-npmtest-jugglingdb/node_modules/jugglingdb/lib/adapters/neo4j.js":"var safeRequire = require('../utils').safeRequire;\n\n/**\n * Module dependencies\n */\nvar neo4j = safeRequire('neo4j');\n\nexports.initialize = function initializeSchema(schema, callback) {\n    schema.client = new neo4j.GraphDatabase(schema.settings.url);\n    schema.adapter = new Neo4j(schema.client);\n    process.nextTick(callback);\n};\n\nfunction Neo4j(client) {\n    this._models = {};\n    this.client = client;\n    this.cache = {};\n}\n\nNeo4j.prototype.define = function defineModel(descr) {\n    this.mixClassMethods(descr.model, descr.properties);\n    this.mixInstanceMethods(descr.model.prototype, descr.properties);\n    this._models[descr.model.modelName] = descr;\n};\n\nNeo4j.prototype.createIndexHelper = function (cls, indexName) {\n    var db = this.client;\n    var method = 'findBy' + indexName[0].toUpperCase() + indexName.substr(1);\n    cls[method] = function (value, cb) {\n        db.getIndexedNode(cls.tableName, indexName, value, function (err, node) {\n            if (err) return cb(err);\n            if (node) {\n                node.data.id = node.id;\n                cb(null, new cls(node.data));\n            } else {\n                cb(null, null);\n            }\n        });\n    };\n};\n\nNeo4j.prototype.mixClassMethods = function mixClassMethods(cls, properties) {\n    var neo = this;\n\n    Object.keys(properties).forEach(function (name) {\n        if (properties[name].index) {\n            neo.createIndexHelper(cls, name);\n        }\n    });\n\n    cls.setupCypherQuery = function (name, queryStr, rowHandler) {\n        cls[name] = function cypherQuery(params, cb) {\n            if (typeof params === 'function') {\n                cb = params;\n                params = [];\n            } else if (params.constructor.name !== 'Array') {\n                params = [params];\n            }\n\n            var i = 0;\n            var q = queryStr.replace(/\\?/g, function () {\n                return params[i++];\n            });\n\n            neo.client.query(function (err, result) {\n                if (err) return cb(err, []);\n                cb(null, result.map(rowHandler));\n            }, q);\n        };\n    };\n\n    /**\n     * @param from - id of object to check relation from\n     * @param to - id of object to check relation to\n     * @param type - type of relation\n     * @param direction - all | incoming | outgoing\n     * @param cb - callback (err, rel || false)\n     */\n    cls.relationshipExists = function relationshipExists(from, to, type, direction, cb) {\n        neo.node(from, function (err, node) {\n            if (err) return cb(err);\n            node._getRelationships(direction, type, function (err, rels) {\n                if (err && cb) return cb(err);\n                if (err && !cb) throw err;\n                var found = false;\n                if (rels && rels.forEach) {\n                    rels.forEach(function (r) {\n                        if (r.start.id === from && r.end.id === to) {\n                            found = true;\n                        }\n                    });\n                }\n                cb  && cb(err, found);\n            });\n        });\n    };\n\n    cls.createRelationshipTo = function createRelationshipTo(id1, id2, type, data, cb) {\n        var fromNode, toNode;\n        neo.node(id1, function (err, node) {\n            if (err && cb) return cb(err);\n            if (err && !cb) throw err;\n            fromNode = node;\n            ok();\n        });\n        neo.node(id2, function (err, node) {\n            if (err && cb) return cb(err);\n            if (err && !cb) throw err;\n            toNode = node;\n            ok();\n        });\n        function ok() {\n            if (fromNode && toNode) {\n                fromNode.createRelationshipTo(toNode, type, cleanup(data), cb);\n            }\n        }\n    };\n\n    cls.createRelationshipFrom = function createRelationshipFrom(id1, id2, type, data, cb) {\n        cls.createRelationshipTo(id2, id1, type, data, cb);\n    }\n\n    // only create relationship if it is not exists\n    cls.ensureRelationshipTo = function (id1, id2, type, data, cb) {\n        cls.relationshipExists(id1, id2, type, 'outgoing', function (err, exists) {\n            if (err && cb) return cb(err);\n            if (err && !cb) throw err;\n            if (exists) return cb && cb(null);\n            cls.createRelationshipTo(id1, id2, type, data, cb);\n        });\n    }\n};\n\nNeo4j.prototype.mixInstanceMethods = function mixInstanceMethods(proto) {\n    var neo = this;\n\n    /**\n     * @param obj - Object or id of object to check relation with\n     * @param type - type of relation\n     * @param cb - callback (err, rel || false)\n     */\n    proto.isInRelationWith = function isInRelationWith(obj, type, direction, cb) {\n        this.constructor.relationshipExists(this.id, obj.id || obj, type, 'all', cb);\n    };\n};\n\nNeo4j.prototype.node = function find(id, callback) {\n    if (this.cache[id]) {\n        callback(null, this.cache[id]);\n    } else {\n        this.client.getNodeById(id, function (err, node) {\n            if (node) {\n                this.cache[id] = node;\n            }\n            callback(err, node);\n        }.bind(this));\n    }\n};\n\nNeo4j.prototype.create = function create(model, data, callback) {\n    var table = this.table(model);\n    data.nodeType = table;\n    var node = this.client.createNode();\n    node.data = cleanup(data);\n    node.data.nodeType = table;\n    node.save(function (err) {\n        if (err) {\n            return callback(err);\n        }\n        this.cache[node.id] = node;\n        node.index(table, 'id', node.id, function (err) {\n            if (err) return callback(err);\n            this.updateIndexes(model, node, function (err) {\n                if (err) return callback(err);\n                callback(null, node.id);\n            });\n        }.bind(this));\n    }.bind(this));\n};\n\nNeo4j.prototype.updateIndexes = function updateIndexes(model, node, cb) {\n    var props = this._models[model].properties;\n    var wait = 1;\n    var table = this.table(model);\n    Object.keys(props).forEach(function (key) {\n        if (props[key].index && node.data[key]) {\n            wait += 1;\n            node.index(table, key, node.data[key], done);\n        }\n    });\n\n    done();\n\n    var error = false;\n    function done(err) {\n        error = error || err;\n        if (--wait === 0) {\n            cb(error);\n        }\n    }\n};\n\nNeo4j.prototype.save = function save(model, data, callback) {\n    var self = this;\n    this.node(data.id, function (err, node) {\n        //delete id property since that's redundant and we use the node.id\n        delete data.id;\n        if (err) return callback(err);\n        node.data = cleanup(data);\n        node.save(function (err) {\n            if (err) return callback(err);\n            self.updateIndexes(model, node, function (err) {\n                if (err) return console.log(err);\n                //map node id to the id property being sent back\n                node.data.id = node.id;\n                callback(null, node.data);\n            });\n        });\n    });\n};\n\nNeo4j.prototype.exists = function exists(model, id, callback) {\n    delete this.cache[id];\n    this.node(id, callback);\n};\n\nNeo4j.prototype.find = function find(model, id, callback) {\n    delete this.cache[id];\n    this.node(id, function (err, node) {\n        if (node && node.data) {\n            node.data.id = id;\n        }\n        callback(err, this.readFromDb(model, node && node.data));\n    }.bind(this));\n};\n\nNeo4j.prototype.readFromDb = function readFromDb(model, data) {\n    if (!data) return data;\n    var res = {};\n    var props = this._models[model].properties;\n    Object.keys(data).forEach(function (key) {\n        if (props[key] && props[key].type.name === 'Date') {\n            res[key] = new Date(data[key]);\n        } else {\n            res[key] = data[key];\n        }\n    });\n    return res;\n};\n\nNeo4j.prototype.destroy = function destroy(model, id, callback) {\n    var force = true;\n    this.node(id, function (err, node) {\n        if (err) return callback(err);\n        node.delete(function (err) {\n            if (err) return callback(err);\n            delete this.cache[id];\n        }.bind(this), force);\n    });\n};\n\nNeo4j.prototype.all = function all(model, filter, callback) {\n    this.client.queryNodeIndex(this.table(model), 'id:*', function (err, nodes) {\n        if (nodes) {\n            nodes = nodes.map(function (obj) {\n                obj.data.id = obj.id;\n                return this.readFromDb(model, obj.data);\n            }.bind(this));\n        }\n        if (filter) {\n            nodes = nodes ? nodes.filter(applyFilter(filter)) : nodes;\n            if (filter.order) {\n                var key = filter.order.split(' ')[0];\n                var dir = filter.order.split(' ')[1];\n                nodes = nodes.sort(function (a, b) {\n                    return a[key] > b[key];\n                });\n                if (dir === 'DESC') nodes = nodes.reverse();\n            }\n        }\n        callback(err, nodes);\n    }.bind(this));\n};\n\nNeo4j.prototype.allNodes = function all(model, callback) {\n    this.client.queryNodeIndex(this.table(model), 'id:*', function (err, nodes) {\n        callback(err, nodes);\n    });\n};\n\nfunction applyFilter(filter) {\n    if (typeof filter.where === 'function') {\n        return filter.where;\n    }\n    var keys = Object.keys(filter.where || {});\n    return function (obj) {\n        var pass = true;\n        keys.forEach(function (key) {\n            if (!test(filter.where[key], obj[key])) {\n                pass = false;\n            }\n        });\n        return pass;\n    }\n\n    function test(example, value) {\n        if (typeof value === 'string' && example && example.constructor.name === 'RegExp') {\n            return value.match(example);\n        }\n        if (typeof value === 'object' && value.constructor.name === 'Date' && typeof example === 'object' && example.constructor.name === 'Date') {\n            return example.toString() === value.toString();\n        }\n        // not strict equality\n        return example == value;\n    }\n}\n\nNeo4j.prototype.destroyAll = function destroyAll(model, callback) {\n    var wait, error = null;\n    this.allNodes(model, function (err, collection) {\n        if (err) return callback(err);\n        wait = collection.length;\n        collection && collection.forEach && collection.forEach(function (node) {\n            node.delete(done, true);\n        });\n    });\n\n    function done(err) {\n        error = error || err;\n        if (--wait === 0) {\n            callback(error);\n        }\n    }\n};\n\nNeo4j.prototype.count = function count(model, callback, conds) {\n    this.all(model, {where: conds}, function (err, collection) {\n        callback(err, collection ? collection.length : 0);\n    });\n};\n\nNeo4j.prototype.updateAttributes = function updateAttributes(model, id, data, cb) {\n    data.id = id;\n    this.node(id, function (err, node) {\n        this.save(model, merge(node.data, data), cb);\n    }.bind(this));\n};\n\nNeo4j.prototype.table = function (model) {\n    return this._models[model].model.tableName;\n};\n\nfunction cleanup(data) {\n    if (!data) return null;\n    \n    var res = {};\n    Object.keys(data).forEach(function (key) {\n        var v = data[key];\n        if (v === null) {\n            // skip\n            // console.log('skip null', key);\n        } else if (v && v.constructor.name === 'Array' && v.length === 0) {\n            // skip\n            // console.log('skip blank array', key);\n        } else if (typeof v !== 'undefined') {\n            res[key] = v;\n        }\n    });\n    return res;\n}\n\nfunction merge(base, update) {\n    Object.keys(update).forEach(function (key) {\n        base[key] = update[key];\n    });\n    return base;\n}\n","/home/travis/build/npmtest/node-npmtest-jugglingdb/node_modules/jugglingdb/lib/adapters/riak.js":"var safeRequire = require('../utils').safeRequire;\n\n/**\n * Module dependencies\n */\nvar uuid = require('node-uuid');\nvar riak = safeRequire('riak-js');\n\nexports.initialize = function initializeSchema(schema, callback) {\n    schema.client = riak.getClient({\n        host: schema.settings.host || '127.0.0.1',\n        port: schema.settings.port || 8091\n    });\n    schema.adapter = new Riak(schema.client);\n};\n\nfunction Riak(client) {\n    this._models = {};\n    this.client = client;\n}\n\nRiak.prototype.define = function (descr) {\n    this._models[descr.model.modelName] = descr;\n};\n\nRiak.prototype.save = function (model, data, callback) {\n    this.client.save(this.table(model), data.id, data, callback);\n};\n\nRiak.prototype.create = function (model, data, callback) {\n    data.id = uuid();\n    this.save(model, data, function (err) {\n        if (callback) {\n            callback(err, data.id);\n        }\n    });\n};\n\nRiak.prototype.exists = function (model, id, callback) {\n    this.client.exists(this.table(model), id, function (err, exists, meta) {\n        if (callback) {\n            callback(err, exists);\n        }\n    });\n};\n\nRiak.prototype.find = function find(model, id, callback) {\n    this.client.get(this.table(model), id, function (err, data, meta) {\n        if (data && data.id) {\n            data.id = id;\n        } else {\n            data = null;\n        }\n        if (typeof callback === 'function') callback(err, data);\n    });\n};\n\nRiak.prototype.destroy = function destroy(model, id, callback) {\n    this.client.remove(this.table(model), id, function (err) {\n        callback(err);\n    });\n};\n\nRiak.prototype.all = function all(model, filter, callback) {\n    var opts = {};\n    if (filter && filter.where) opts.where = filter.where;\n    this.client.getAll(this.table(model), function (err, result, meta) {\n        if (err) return callback(err, []);\n        /// return callback(err, result.map(function (x) { return {id: x}; }));\n        result = (result || []).map(function (row) {\n            var record = row.data;\n            record.id = row.meta.key;\n            console.log(record);\n            return record;\n        });\n\n        return callback(err, result);\n    }.bind(this));\n};\n\nRiak.prototype.destroyAll = function destroyAll(model, callback) {\n    var self = this;\n    this.all(this.table(model), {}, function (err, recs) {\n        if (err) callback(err);\n\n        removeOne();\n\n        function removeOne(error) {\n            err = err || error;\n            var rec = recs.pop();\n            if (!rec) return callback(err && err.statusCode != '404' ? err : null);\n            console.log(rec.id);\n            self.client.remove(this.table(model), rec.id, removeOne);\n        }\n\n    });\n\n};\n\nRiak.prototype.count = function count(model, callback) {\n    this.client.keys(this.table(model) + ':*', function (err, keys) {\n        callback(err, err ? null : keys.length);\n    });\n};\n\nRiak.prototype.updateAttributes = function updateAttrs(model, id, data, cb) {\n    data.id = id;\n    this.save(model, data, cb);\n};\n\nRiak.prototype.table = function (model) {\n    return this._models[model].model.tableName;\n};\n"}